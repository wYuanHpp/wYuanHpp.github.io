<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-理解前端依赖" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/理解前端依赖/" class="article-date">
  <time datetime="2020-07-28T03:20:00.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/理解前端依赖/">理解前端依赖</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现代的前端开发, 每个前端工程师都需要自己的项目添加第三方依赖, 也会自己开发的第三方库进行对外发布, 而承担这些功能的我们叫它包管理器, 世面上常见的包管理器有<code>bower</code> <code>npm</code> <code>yarn</code>, 这三个里<code>npm</code>是使用最为广泛的.</p>
<p>因为前端依赖是允许再同一个项目中可能在不同层级的依赖上使用同一个第三方依赖的多个版本, 所以前端的依赖管理逻辑往往让人理不清. 这本质的原因在于当允许依赖树中出现多个相同的依赖, 就会出现’环’这种东西, 所以实际上依赖应该被解析成<code>graph</code> 而不是 <code>tree</code>, 但是在文件系统确只能表达<code>tree</code>, 因此在不同的<code>npm</code>版本, 对于依赖的解析也有不同的方式, 我们下面提到的均是以v6版本为基础的.</p>
<h2 id="npm是如何解析项目依赖的"><a href="#npm是如何解析项目依赖的" class="headerlink" title="npm是如何解析项目依赖的"></a>npm是如何解析项目依赖的</h2><p>在前端项目里, 基本上都能看到一个名叫<code>package.json</code>的文件, 里面有一部分重要的字段, 比如<code>dependencies</code> <code>devDependencies</code> 等等,都是是用来记录项目依赖的, 相关字段的区别无非是设置依赖的安装条件而已, 具体的可以查看<a href="https://docs.npmjs.com/files/package.json#dependencies" target="_blank" rel="noopener">官方文档</a>, 这里不再赘述. 项目里的所有依赖都是有版本标记的, 他们都使用同一种版本命名法<a href="https://semver.org/" target="_blank" rel="noopener">Semantic</a>, 这可以让<code>npm</code>很好的对相同第三方库的版本进行区分和排序, 这也是能够实现一个依赖树中出现多个相同第三方库的基础.</p>
<p>我们知道, 前端项目不仅仅有<code>package.json</code>这个文件, 还有一个目录叫做<code>node_modules</code>. ‘package.json’是用来描述我们的项目依赖, 而<code>node_modules</code>则是用来保存对应的第三方依赖包的, 那么npm是如何通过<code>package.json</code>来构建<code>node_modules</code>文件夹的呢?</p>
<p>我还是直接上一个例子吧!</p>
<p>下面是一个项目<code>mage</code>的一个依赖图:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- sugar-design@1.0.0 // 直接依赖</span><br><span class="line">    +-- react@16.2.0 </span><br><span class="line">    +-- classname@5.0.0</span><br></pre></td></tr></table></figure></p>
<p>首先, <code>npm</code>会尝试吧所有的依赖扁平化的保存到最顶级的<code>node_modules</code>, 也就是生成下面这样的文件结构:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- node_modules</span><br><span class="line">  +-- sugar-design@1.0.0</span><br><span class="line">  +-- react@16.2.0</span><br><span class="line">  +-- classname@5.0.0</span><br></pre></td></tr></table></figure></p>
<p>当我们给<code>mage</code>添加一个新的依赖<a href="mailto:react@16.13.1" target="_blank" rel="noopener">react@16.13.1</a>时, <code>mage</code>的依赖图会变成这样:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- react@16.13.1</span><br><span class="line">+-- sugar-design@1.0.0</span><br><span class="line">    +-- react@16.2.0</span><br><span class="line">    +-- classname@5.0.0</span><br></pre></td></tr></table></figure>
<p>那么接下来<code>node_modules</code>的文件结构会变成怎样呢?</p>
<ol>
<li>根据项目的顶级依赖, 顶级<code>node_modules</code>安装<a href="mailto:react@16.13.1" target="_blank" rel="noopener">react@16.13.1</a></li>
<li>由于顶级<code>node_modules</code>目录已经安装了<a href="mailto:react@16.13.1" target="_blank" rel="noopener">react@16.13.1</a>, 而<code>sugar-design</code>依赖的<code>react</code>版本是16.2.0, 所以只能安装在它内部的<code>node_modules</code>里</li>
</ol>
<p>所以文件结构会是这样:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- node_modules</span><br><span class="line">  +-- react@16.13.1</span><br><span class="line">  +-- sugar-design@1.0.0</span><br><span class="line">  |   +-- node_modules</span><br><span class="line">  |       +-- react@16.2.0</span><br><span class="line">  +-- classname@5.0.0</span><br></pre></td></tr></table></figure></p>
<p>ok, 我们继续, 现在我们又为<code>mage</code>增加一个新的依赖<a href="mailto:editor@1.0.0" target="_blank" rel="noopener">editor@1.0.0</a>, 它依赖于<a href="mailto:react@16.2.0" target="_blank" rel="noopener">react@16.2.0</a> 和 <a href="mailto:className@5.0.0" target="_blank" rel="noopener">className@5.0.0</a></p>
<p>对应的依赖图:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- react@16.13.1</span><br><span class="line">+-- sugar-design@1.0.0</span><br><span class="line">|   +-- react@16.2.0</span><br><span class="line">|   +-- classname@5.0.0 </span><br><span class="line">+-- editor@1.0.0</span><br><span class="line">    +-- react@16.2.0</span><br><span class="line">|   +-- classname@5.0.0</span><br></pre></td></tr></table></figure>
<p>接下来<code>npm</code>再安装依赖的时候会这样做:</p>
<ul>
<li>在顶级<code>node_modules</code>上安装<a href="mailto:editor@1.0.0" target="_blank" rel="noopener">editor@1.0.0</a></li>
<li>由于它依赖的<code>react</code>版本和顶级<code>node_modules</code>的<code>react</code>版本不匹配, 所以在它的内部<code>node_modules</code>里安装<a href="mailto:react@16.2.0" target="_blank" rel="noopener">react@16.2.0</a></li>
<li>由于它依赖的<code>classname</code>版本和顶级<code>node_modules</code>的<code>classname</code>版本匹配本, 所以不需要再单独安装</li>
</ul>
<p>文件结构会是这样:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- node_modules</span><br><span class="line">  +-- react@16.13.1</span><br><span class="line">  +-- sugar-design@1.0.0</span><br><span class="line">  |   +-- node_modules</span><br><span class="line">  |       +-- react@16.2.0</span><br><span class="line">  +-- classname@5.0.0 </span><br><span class="line">  +-- editor@1.0.0</span><br><span class="line">      +-- node_modules</span><br><span class="line">          +-- react@16.2.0</span><br></pre></td></tr></table></figure></p>
<p>我们看到, 在安装依赖时, 都是优先安装在顶级<code>node_modules</code>上, 如果有已经用相同的第三方库已经安装, 则在子级<code>node_modules</code>上安装, 如果还有, 则以此类推</p>
<p>最后让我们把<code>sugar-design</code>的版本进行一次升级, 新的版本也同时升级了它的依赖, 把<code>react</code>升级到了<code>16.13.1</code> <code>classname</code> 升级到了 <code>6.0.0</code>, 对应的依赖图是:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- react@16.13.1</span><br><span class="line">+-- sugar-design@2.0.0</span><br><span class="line">|   +-- react@16.13.1</span><br><span class="line">|   +-- classname@6.0.0 </span><br><span class="line">+-- editor@1.0.0</span><br><span class="line">    +-- react@16.2.0</span><br><span class="line">|   +-- classname@5.0.0</span><br></pre></td></tr></table></figure>
<p>接下来会发生:</p>
<ul>
<li>由于祖先有相同版本的react, 所以移除了<code>sugar-design</code>内部的<code>react</code></li>
<li>由于安装顺序原因<code>sugar-design</code>的<a href="mailto:classname@6.0.0" target="_blank" rel="noopener">classname@6.0.0</a>会安装在<code>node_modules</code>根目录上, 所以<code>editor</code>在内部<code>node_modules</code>安装<a href="mailto:classname@5.0.0" target="_blank" rel="noopener">classname@5.0.0</a></li>
</ul>
<p>最后的文件结构会是这样:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- node_modules</span><br><span class="line">  +-- react@16.13.1</span><br><span class="line">  +-- sugar-design@2.0.0</span><br><span class="line">  +-- classname@6.0.0 </span><br><span class="line">  +-- editor@1.0.0</span><br><span class="line">      +-- node_modules</span><br><span class="line">          +-- react@16.2.0</span><br><span class="line">          +-- classname@5.0.0</span><br></pre></td></tr></table></figure>
<p>最后的最后, 我们来测试一下变换声明顺序:</p>
<p>我们把<code>sugar-design</code> 和 <code>editor</code>的声明顺序对调一下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- react@16.13.1</span><br><span class="line">+-- editor@1.0.0 // 对调了</span><br><span class="line">|   +-- react@16.2.0</span><br><span class="line">|   +-- classname@5.0.0 </span><br><span class="line">+-- sugar-design@2.0.0 // 对调了</span><br><span class="line">    +-- react@16.13.1</span><br><span class="line">    +-- classname@6.0.0</span><br></pre></td></tr></table></figure></p>
<p>对调后,虽然最后加载的版本没错, 但是生成的文件结构变了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- node_modules</span><br><span class="line">  +-- react@16.13.1</span><br><span class="line">  +-- sugar-design@2.0.0</span><br><span class="line">      +-- node_modules</span><br><span class="line">          +-- classname@6.0.0 // sugar-design 的依赖到了自己的内部</span><br><span class="line">  +-- classname@5.0.0  // editor 的依赖classname到了顶级</span><br><span class="line">  +-- editor@1.0.0</span><br><span class="line">      +-- node_modules</span><br><span class="line">          +-- react@16.2.0</span><br></pre></td></tr></table></figure>
<p>ok, 例子结束, 我们整理一下上面的例子, 得到一下的结论: </p>
<ul>
<li>npm安装依赖时, 会尝试吧所有的依赖扁平化的安装在<code>node_modules</code>根目录</li>
<li>如果祖先对应的依赖版本不匹配的话, 将在自己的内部<code>node_modules</code>内进行安装, 以此类推</li>
<li>安装顺序和依赖的声明顺序有关, 所以声明顺序变了, 最后生成的`node_modules’结构可能会不同</li>
</ul>
<p>经过上面的饿总结, 相信大家对npm的依赖安装逻辑已经有足够的了解了.</p>
<p>那么我们想一想, 依赖加载时, 查找的逻辑是什么呢? 其实从上面的依赖安装逻辑已经可以看出来了, 实际上就是’最近原则’, 也就是说先查找自己的<code>node_modules</code>, 没有就依次往上查找上级<code>node_modules</code>, 直到找到为止. 值得注意的是, 在真正调用依赖的时候, 系统并不会去验证版本号, 只要找到就进行加载, 版本号的验证都在安装阶段进行校验的</p>
<p>虽然了解了安装依赖的逻辑, 但是这对我们日常工作能有什么帮助呢? 毕竟日常当中, 我们往往是引入第三方库, 而不是发布第三方库. 如果我们是一个第三方库的作者, 我们需要在这方面注意什么呢?</p>
<h2 id="第三方库开发误区"><a href="#第三方库开发误区" class="headerlink" title="第三方库开发误区"></a>第三方库开发误区</h2><p>现在的前端工程, 离不开打包工具, 不管是<code>webpack</code> 还是<code>rollup</code>, 他们的核心理念都是吧多个模块封装到一个模块里.所以在我们开发的时候往往会对<code>package.json</code>內声明的依赖不太重视, 以为只要代码打包, 所有的依赖都已经打入构建好的源码中了, <code>package.json</code>里的东西只会在第三方库内部开发时才会用到, 不会对引用第三方库的人产生什么影响. 实际上这完全是错误的. 因为只要你的第三方库中的<code>package.json</code>声明了<code>dependencies</code>, 那么引入这个第三方的项目就都需要安装它, 虽然项目里确实不会真的引用到这些依赖. </p>
<p>上面这种情况, 虽然会安装多余的依赖, 但是并不会对项目本身产生多少负面作用.但接下来一个情况, 可能会对项目有重大印象, 并且在做bug排查时, 也可能会遇到很大的困难, 比如(Invalid Hook Call Warning)[<a href="https://reactjs.org/warnings/invalid-hook-call-warning.html]" target="_blank" rel="noopener">https://reactjs.org/warnings/invalid-hook-call-warning.html]</a>.</p>
<p>首先我们应该理解一个概念, 在开发第三方库时, 应该吧运行时的依赖写在<code>dependencies</code>里.</p>
<p>如果我们开发的第三方库并不希望再运行时使用自己的依赖, 而是使用宿主的依赖, 比如<code>react</code> <code>classname</code> <code>react-dom</code>, 通常我们会对打包工具的<code>external</code>字段进行配置, 这样打包工具就不会把我们的对应依赖打入构建后的代码里. 这时构建好的第三方库是没对应的依赖的. 但是在其他项目引入我们写第三方库时, 项目打包工具在编译到我们的第三方库时, 由于我们的第三方库没有打包对应的依赖, 所以会去尝试加载我们第三方库的依赖,这时, 打包工具会去查找我们自己写第三方库下面的<code>node_modules</code>是否这些依赖, 如果第三方库里的依赖是使用<code>dependencies</code>来声明的话, 很有可能因为声明的版本和宿主环境的不同导致在内部又多安装了一份依赖, 构建工具最终会把我们自己写的第三方库的依赖也打入最后的项目构建代码中, 这样就会导致, 打入了多个不同版本的依赖, 就像下图</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mage</span><br><span class="line">+-- node_modules</span><br><span class="line">  +-- react@16.13.1 // 计划使用宿主的react</span><br><span class="line">  +-- sugar-design@2.0.0 // &lt;- 我们自己的第三方库</span><br><span class="line">      +-- node_modules</span><br><span class="line">          +-- react@16.2.0 // 实际加载的是自己的依赖react</span><br></pre></td></tr></table></figure>
<p>所以最好的方法是使用<code>peerDependencies</code>, 为什么不是<code>dependencies</code>呢? 因为<code>peerDependencies</code>可以保证你的第三方库不会额外引入一个<code>react</code> <code>react-dom</code>. 而像<code>react</code> <code>react-dom</code>这样的库, 因为设计原因, 同时引入多个可能会造成未知的错误, 而在排查这类bug的时候确往往是很困难的.</p>
<p>如果真的发生了上面说的问题, 应该怎么办呢?</p>
<h2 id="如何找到多次引入的第三方包呢"><a href="#如何找到多次引入的第三方包呢" class="headerlink" title="如何找到多次引入的第三方包呢?"></a>如何找到多次引入的第三方包呢?</h2><p>如果真的想确定是否有多个第三方库被引入呢? 以<code>rect</code>为例, 我这几个一个办法:</p>
<p><strong>第一个</strong><br>你可以使用<code>npm</code>命令, 查看当前的dependency graph:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls react</span><br></pre></td></tr></table></figure></p>
<p>上面的命令可以查看, 到底项目里有多少个第三方库依赖<code>react</code>, 之后在逐一进行排查.</p>
<p><strong>第二个</strong><br>首先在开发环境运行项目, 打开浏览器控制台: 按住 <code>command</code> + <code>p</code>, 并在出现的输入框中输入<code>react.dev</code></p>
<p><img src="https://moka-sugar.oss-cn-beijing.aliyuncs.com/img/dedupe.png" alt></p>
<p>如果出现多个结果, 但是来源却不一致, 就像上图一样, 那么恭喜你, 你已经找到了!</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>所以, 请大家在写第三方库<code>package.json</code>的依赖部分时, 保持谨慎, 防止以外发生, 最好现在就去检查一下你写得第三方库是不是就有这类问题. 我相信将来<code>npm</code>也会为我们作更多的工作, 减少这些维护的成本.<br>因为<code>npm</code>一直再持续的迭代版本, 目前v7也在紧张的开发中, 这次带来了功能更强大的依赖树管理工具<a href="https://blog.npmjs.org/post/618653678433435649/npm-v7-series-arborist-deep-dive" target="_blank" rel="noopener">arborist</a>, 感兴趣的同学可以进行深入了解.</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://medium.com/learnwithrahul/understanding-npm-dependency-resolution-84a24180901b" target="_blank" rel="noopener">Understanding npm dependency resolution</a></p>
<p><a href="https://lexi-lambda.github.io/blog/2016/08/24/understanding-the-npm-dependency-model/" target="_blank" rel="noopener">Understanding the npm dependency model</a></p>
<p><a href="https://docs.npmjs.com/cli-commands/install.html" target="_blank" rel="noopener">npm install guideline</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/理解前端依赖/" data-id="ckd5eq8f6000ftpro6ezl32qr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-理解DSL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/30/理解DSL/" class="article-date">
  <time datetime="2020-06-30T03:28:48.000Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/30/理解DSL/">理解DSL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一个简单问题"><a href="#一个简单问题" class="headerlink" title="一个简单问题"></a>一个简单问题</h3><p>如何使用程序来描述下面一个问题?</p>
<p>再一组候选人当中, 找到满足下列条件的数据:</p>
<ul>
<li>所有候选人性别为女</li>
<li>数据按年龄排序</li>
<li>是输出姓名以及年龄信息</li>
</ul>
<p>ok, 问题已经抛出来了, 那么让我们用<code>js</code>来实现这个需求.</p>
<p>假设数据集叫<code>data</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.sex === <span class="string">'woman'</span>)</span><br><span class="line">.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.age - b.age)</span><br><span class="line">.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123; <span class="attr">name</span>: item.item, <span class="attr">age</span>: item.ange &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码看上去, 再对<code>js</code>语言十分熟悉的人看来, 可以很快的看明白代码的意思, 但是如果是外行, 那可能有点难猜了, 那么有没有什么办法, 用更简单更易懂的方式来描述这个问题呢?</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'name'</span>, <span class="string">'age'</span> <span class="keyword">from</span> <span class="string">'data'</span> <span class="keyword">where</span> sex = <span class="string">'woman'</span> sortBy <span class="string">'age'</span></span><br></pre></td></tr></table></figure>
<p>上面是一条<code>SQL</code>语句, 相信不管是不是程序员, 都能够快速理解这段语句的含义. 显然<code>SQL</code>再数据查询这个领域, 比<code>js</code>更加简洁, 表达力更强. 我们管这种再针对特殊领域的语言叫DSL(特殊领域语言)</p>
<h3 id="什么是DSL"><a href="#什么是DSL" class="headerlink" title="什么是DSL"></a>什么是DSL</h3><p>DSL是(Domain Specific Language)特定领域语言, 是做处理某一个特定领域的问题设计出来的语言, 这类语言比较简单, 再专属的领域内, 有非常强的表达力.</p>
<p>与之相对的是GPL(General Purpose Language) 通用编程语言. 这类语言是能够表达可被计算的逻辑, 必须是图灵完备, 他们的侧重点是灵活,全面.  Java/python/js/go/c 这类都属于GPL</p>
<h3 id="典型的DSL有哪些"><a href="#典型的DSL有哪些" class="headerlink" title="典型的DSL有哪些?"></a>典型的DSL有哪些?</h3><ul>
<li>HTML</li>
<li>CSS</li>
<li>JSX</li>
<li>PUG</li>
<li>REGEX</li>
<li>SQL</li>
<li>XML</li>
<li>YMAL</li>
</ul>
<p>上面的这些语言, 大家可以发现, 几乎都不是图灵完毕的计算机语言(为实现if空值/循环), 他们的语法很简单, 主要以声明式的表达方法来进行编写的</p>
<p>因为是使用声明式的表达方式, 所以在在阅读上会更加流畅</p>
<h3 id="为什么要用DSL"><a href="#为什么要用DSL" class="headerlink" title="为什么要用DSL"></a>为什么要用DSL</h3><p>DSL往往语法简单, 并且非常易于阅读, 再其擅长的领域内编码是非常高效的.<br>我们再拿HTML 和 js对象做一个对比:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">name</span>: <span class="string">'div'</span>, <span class="attr">class</span>: <span class="string">'container'</span>, <span class="attr">children</span>: <span class="string">'hello world'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>js</code>来描述一个html节点, 只能把所有的属性平铺到一个对象中, 让人再阅读中无法找到重点, 并有效的区分区别</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span> hello world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用了xml语法, 可以快速辨别标签类型, 和内容, 整体语义化很强, 缺点就是有多余的符号和为了表达嵌套关系的闭合标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div(class=&apos;container&apos;) hello world</span><br></pre></td></tr></table></figure>
<p>使用<code>pug</code>独特的语法, 再不损失xml的表达力的前提下, 省略了无用的符号, 并通过缩进来表达嵌套逻辑, 降低了很多的语法噪音</p>
<p>可以看出来, DSL的引入确实能够有效的提高特定场景的表达效率, 再熟悉了相关语法后, 能够是代码更易理解, 也更加简洁</p>
<h3 id="要不要引入DSL"><a href="#要不要引入DSL" class="headerlink" title="要不要引入DSL"></a>要不要引入DSL</h3><p>再日常开发当中, 为了解决某一个场景的需求而引入一个新的DSL, 在我来看是需要谨慎考虑的. 因为这实际是引入了一种新的语言. 这可能会让整个项目的维护难度提升,<br>所以是否引入DSL需要考察几个点</p>
<ul>
<li>产能的提升是否能够抹平新语言引入带来的学习成本</li>
<li>是否可以用相关第三方工具替代DSL</li>
</ul>
<h3 id="内部-外部"><a href="#内部-外部" class="headerlink" title="内部? 外部?"></a>内部? 外部?</h3><p>既然引入DSL是有成本的, 那么有没有什么成本比较低的引入方法? </p>
<p>也许有, 上面我们谈到的DSL在广义上作区分的话, 叫做外部DSL, 那么既然有外部DSL, 那肯定有内部DSL, 下面我举一个例子:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'name'</span> <span class="keyword">from</span> <span class="string">'application'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">12345</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="string">'name'</span>)</span><br><span class="line">.from(<span class="string">'application'</span>)</span><br><span class="line">.where(id, <span class="string">'='</span>, <span class="number">12345</span>)</span><br></pre></td></tr></table></figure>
<p>上面的<code>sql</code>和下面的<code>js</code>代码实际上是等价的, 上面的<code>sql</code>我们叫它外部DSL, 下面的<code>js</code>叫做内部DSL.</p>
<p>再来一个例子:</p>
<p><em>外部DSL</em>:<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">10px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>内部DSL</em>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.container .content'</span>)</span><br><span class="line">.css(<span class="string">'color'</span>, <span class="string">'#fff'</span>)</span><br><span class="line">.css(<span class="string">'margin'</span>, <span class="string">'10px'</span>)</span><br></pre></td></tr></table></figure></p>
<p>显然这个内部DSL看着很眼熟, 感觉就是我们普通的<code>js</code>方法调用, 就是普通第三方库的接口调用. 实际上没有错, 内部DSL还有一个其他名字-流畅几口(fluency)</p>
<p>类似这样的内部DSL我们见过很多:</p>
<p><em>jquery</em>:<br>JQuery可以被称作是对dom操作的内部DSL</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.mydiv'</span>)</span><br><span class="line">.addClass(<span class="string">'flash'</span>)</span><br><span class="line">.draggable()</span><br><span class="line">.css(<span class="string">'color'</span>, <span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure>
<p><em>Moment</em><br>Moment 就可以被称作是对日期操作的 内部DSL</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moment()</span><br><span class="line">.subtract(<span class="number">10</span>, <span class="string">'days'</span>)</span><br><span class="line">.calendar();</span><br></pre></td></tr></table></figure>
<p><em>Chai</em><br>Chai 就可以被称作是对断言操作的 内部DSL</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tea.should.have.property(<span class="string">'flavors'</span>).with.lengthOf(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="如何区分内部或外部DSL"><a href="#如何区分内部或外部DSL" class="headerlink" title="如何区分内部或外部DSL"></a>如何区分内部或外部DSL</h3><p>通常来讲, 如果实现的功能,无法被宿主语言直接支持, 需要自己额外实现代码的编译和解析, 都属于外部DSL</p>
<p>如果实现的功能, 可以呗宿主语言直接支持, 就想上面的例子一样, 都是简单的函数形式, 那么这就属于内部的DSL</p>
<p>那么这里我有一个问题, 就是我们写<code>React</code>常用的<code>JSX</code>算是什么? 是内部的DSL么? 下面放一点示例代码<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Container&gt;</span><br><span class="line">  &lt;Menu list=&#123;<span class="keyword">this</span>.state.list&#125;/&gt;</span><br><span class="line">  &lt;Footer/&gt;</span><br><span class="line">&lt;<span class="regexp">/Container&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>会被转成:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  Container,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  React.createElement(Menu, &#123;</span><br><span class="line">    list: <span class="keyword">this</span>.state.list</span><br><span class="line">  &#125;),</span><br><span class="line">  React.createElement(Footer, <span class="literal">null</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>最然转义后的代码, 是合法的js代码, 但是源码并不是 一个合法的js代码, 正常的浏览器是无法正常识别这些代码的.<br>因为这些代码再被浏览器执行前, 会被<code>Babel</code>进行转移, 转移成可被浏览器识别的<code>js</code>代码而<code>Babel</code>再转义这些<code>JSX</code>的时候,<br>实际上内部已经实现了对这种特殊语法的编译和解析, 所以, 虽然<code>jsx</code>通常也写在<code>.js</code>文件中, 但它还是一个外部的DSL</p>
<h3 id="如何看待内部DSL"><a href="#如何看待内部DSL" class="headerlink" title="如何看待内部DSL"></a>如何看待内部DSL</h3><p>DSL,实际上就是为了解决特定问题而出现的.<br>使用内部DSL来对某个领域进行扩展,在我看来是一个很好的解决方案, 因为没有引入新语言带来的新问题, </p>
<p>社区对,内部DSL的划分界定实际上很模糊, 希望大家不要过于纠结, 无论是API 还是 DSL, 能够有效的抽象并解决问题的, 都是好的解决之道</p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://zhuanlan.zhihu.com/p/107947462" target="_blank" rel="noopener">前端 DSL 实践指南（上）—— 内部 DSL</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/30/理解DSL/" data-id="ckd5eq8f5000etpro61v6h9wh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-你真的知道react-redux是怎么运行的么" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/19/你真的知道react-redux是怎么运行的么/" class="article-date">
  <time datetime="2020-05-19T03:22:37.000Z" itemprop="datePublished">2020-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/19/你真的知道react-redux是怎么运行的么/">你真的知道react-redux是怎么运行的么</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近我在想状态管理的一些技术, 突然想到, react这种只要一有数据变化就无脑进行reRender的框架, 再引入了redux的全局state后, 到底react-redux做了什么事情? 于是打算看看源码, 了解一下它幕后的故事,<br>由于目前我接触的项目绝大部分还停留在react 15上, 并且为了避免新增的hooks相关的代码干扰, 这次我主要看的是<code>react-redux</code>的5.x版本,毕竟更贴紧业务嘛!</p>
<p>通常看源码最好带一些问题去看效果比较好, 而我再看代码前, 我有以下几个疑问:</p>
<ol>
<li>它是如果进行性能优化的<br>2, 全局state的传递,是通过什么来实现的</li>
<li>如果使用context来传递store信息, 是如何不被CSU阻断的.(react15还在使用老的context api)</li>
</ol>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><code>react-redux</code>有两个主要的api <code>Provider</code> <code>connect</code>. 他们俩类似于广播, 一个是广播塔, 一个是收音机, 我们先从广播塔<code>Provider</code>开始吧!</p>
<p><em>注: 以下的所有源码都被简化, 方便理解</em></p>
<h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>我们先简单看一下用法, 方便对照调用和实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore();</span><br><span class="line"> ReactDOM.render(</span><br><span class="line">   <span class="comment">// 传递 全局状态到provider</span></span><br><span class="line">   &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">     &lt;App /&gt;</span><br><span class="line">   &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">   document.getElementById('root')</span></span><br><span class="line"><span class="regexp"> )</span></span><br></pre></td></tr></table></figure>
<p>ok,调用很简单, 让我们直接进入代码, 显然<code>react-redux</code>确实是使用context api进行全局store的传递的, 通过Provider从根组件传递了两个属性:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="comment">// 添加了两个context属性, 一个store, 一个storeSubscription</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store, <span class="attr">storeSubscription</span>: <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props, context)</span><br><span class="line">    <span class="keyword">this</span>.store = props.store;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出来 <code>Provider</code>只做了很少的事情, 就是把redux的store往下传递, 而这里有一个<code>storeSubscription</code>只是做了一个<code>null</code>的赋值, 那么这个属性到底是干什么的呢? 我们先卖个关子, 接着往下看</p>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>上面说的<code>Provider</code>像是广播塔, 那么收音机<code>connect</code>它的调用方式我们也来回顾一下, 方便后面对照<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">actions</span>: bindActionCreators(actionCreators, dispatch) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最简单的调用, connect是一个高级函数的科里化, 第一次调用传入对应的mapToProps</span></span><br><span class="line"><span class="comment">// 方法, 第二次调用传入需要包裹的组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(TodoApp)</span><br></pre></td></tr></table></figure></p>
<p>通过阅读源码,我发现connect的整个功能被分成了两个部分:</p>
<ol>
<li>提取需要的stateProps, 注入被包裹的组件, 并做有效的缓存和性能优化</li>
<li>通知全局state状态改变</li>
</ol>
<h4 id="提取需要的stateProps"><a href="#提取需要的stateProps" class="headerlink" title="提取需要的stateProps"></a>提取需要的stateProps</h4><p>connect是一个会大规模使用的公共组件, 其性能一定是倍受关注的, 对于react, 除了普通的代码执行层面的优化, 最有效的优化无疑是<code>componentShouldUpdate</code>了, 因为即使有virtue Dom的存在, 依然不可避免的需要走完render函数, 走完diff算法, 而<code>componentShouldUpdate</code>则异常的直接, 只要你返回的是false, 就直接不做后面的所有事情, 无需render, 直接复用之前的元素.</p>
<p>那么如何判断我们的connect是否需要渲染呢?</p>
<ol>
<li>组件本身的props有变化</li>
<li>全局state有变化</li>
</ol>
<p>如上, 组件本身的props,我们是可以很容易拿到的, 任何一个有变化, 都应该reRender, 但是全局State变化, 我们就不一定都需要reRender了, 这个时候, 我们需要依赖的实际上是传入给connect的 <code>mapStateToProps</code> <code>mapDispatchToProps</code>, 他们两个都类似于选择器. 我只需要确认这两个函数的返回值是否有变化, 就可以确认我是否需要reRender, 因为她们的返回值, 最后都会作用下面组件的props上</p>
<h6 id="创建一个selector"><a href="#创建一个selector" class="headerlink" title="创建一个selector"></a>创建一个selector</h6><p>所以最后, 最好结果是组合 <code>mapStateToProps</code> <code>mapDispatchToProps</code> 这些函数, 最后返回一个结果对象, 我们只要判断这个结果对象前后两次是否相同, 就可以判断是否需要reRender, 大概是这样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stateA = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123; <span class="attr">aa</span>: <span class="number">4</span>, <span class="attr">bb</span>: <span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> stateB = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">999</span>, <span class="attr">c</span>: <span class="number">999</span>, <span class="attr">d</span>: &#123; <span class="attr">aa</span>: <span class="number">4</span>, <span class="attr">bb</span>: <span class="number">5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps1</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props1: state.a,</span><br><span class="line">    props2: state.d.bb,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps2</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props3: state.a,</span><br><span class="line">    props4: state.d.aa,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selector</span>(<span class="params">mapToProps1, mapToProps2, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...mapToProps1(state), ...mapToProps2(state)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergedPropsA = selector(mapStateToProps1, mapStateToProps2, stateA);</span><br><span class="line"><span class="keyword">const</span> mergedPropsB = selector(mapStateToProps1, mapStateToProps2, stateB);</span><br><span class="line"></span><br><span class="line">shadowCompile(mergePropsA, mergePropsB); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>上面是简单的实例, 来说明我们的 <code>mapStateToProps</code> <code>mapDispatchToProps</code>是如何来发挥选择器作用的.</p>
<p>下面我们看看<code>react-redux</code>是怎么做的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数会传入我们再connect传入的 mapStateToProps, mapDispatchToProps, mergeProps, 三个函数, 以及dispatch</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pureFinalPropsSelectorFactory</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  mapStateToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapDispatchToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  mergeProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  dispatch,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录是否是第一次执行</span></span><br><span class="line">  <span class="keyword">let</span> hasRunAtLeastOnce = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> state</span><br><span class="line">  <span class="keyword">let</span> ownProps</span><br><span class="line">  <span class="keyword">let</span> stateProps</span><br><span class="line">  <span class="keyword">let</span> dispatchProps</span><br><span class="line">  <span class="comment">// 本函数最后都会返回这个值, 是一个结果对象, 最后会之间传递到被包裹的组件上</span></span><br><span class="line">  <span class="keyword">let</span> mergedProps</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首次执行, 计算props, 并生成缓存</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleFirstCall</span>(<span class="params">firstState, firstOwnProps</span>) </span>&#123;</span><br><span class="line">    state = firstState</span><br><span class="line">    ownProps = firstOwnProps</span><br><span class="line">    stateProps = mapStateToProps(state, ownProps)</span><br><span class="line">    dispatchProps = mapDispatchToProps(dispatch, ownProps)</span><br><span class="line">    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)</span><br><span class="line">    <span class="comment">// 切换标志位</span></span><br><span class="line">    hasRunAtLeastOnce = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> mergedProps</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNewPropsAndNewState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stateProps = mapStateToProps(state, ownProps)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mapDispatchToProps.dependsOnOwnProps)</span><br><span class="line">      dispatchProps = mapDispatchToProps(dispatch, ownProps)</span><br><span class="line"></span><br><span class="line">    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)</span><br><span class="line">    <span class="keyword">return</span> mergedProps</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNewProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mapStateToProps.dependsOnOwnProps)</span><br><span class="line">      stateProps = mapStateToProps(state, ownProps)</span><br><span class="line">    <span class="keyword">if</span> (mapDispatchToProps.dependsOnOwnProps)</span><br><span class="line">      dispatchProps = mapDispatchToProps(dispatch, ownProps)</span><br><span class="line">    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)</span><br><span class="line">    <span class="keyword">return</span> mergedProps</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNewState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nextStateProps = mapStateToProps(state, ownProps)</span><br><span class="line">    <span class="keyword">const</span> statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)</span><br><span class="line">    stateProps = nextStateProps</span><br><span class="line">    <span class="keyword">if</span> (statePropsChanged)</span><br><span class="line">      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)</span><br><span class="line">    <span class="keyword">return</span> mergedProps</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首次执行后都走这个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleSubsequentCalls</span>(<span class="params">nextState, nextOwnProps</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 看组件自己接受的props是否相同</span></span><br><span class="line">    <span class="keyword">const</span> propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)</span><br><span class="line">    <span class="comment">// 判断收到的全局state是否相等, 上面两种方法都这是做浅比较</span></span><br><span class="line">    <span class="keyword">const</span> stateChanged = !areStatesEqual(nextState, state)</span><br><span class="line">    state = nextState</span><br><span class="line">    ownProps = nextOwnProps</span><br><span class="line">    <span class="comment">// 根据不同情况, 做不同处理, 最后的结果都是会去处理 mergedProps这个值</span></span><br><span class="line">    <span class="comment">// 如果都相等就原封不动的返回mergedProps</span></span><br><span class="line">    <span class="keyword">if</span> (propsChanged &amp;&amp; stateChanged) <span class="keyword">return</span> handleNewPropsAndNewState()</span><br><span class="line">    <span class="keyword">if</span> (propsChanged) <span class="keyword">return</span> handleNewProps()</span><br><span class="line">    <span class="keyword">if</span> (stateChanged) <span class="keyword">return</span> handleNewState()</span><br><span class="line">    <span class="keyword">return</span> mergedProps</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入口, 传入的是redux的全局state,和自己本身接受的props</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">selector</span>(<span class="params">nextState, nextOwnProps</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 首次执行 和 之后的执行分别走了不同的函数</span></span><br><span class="line">    <span class="keyword">return</span> hasRunAtLeastOnce</span><br><span class="line">      ? handleSubsequentCalls(nextState, nextOwnProps)</span><br><span class="line">      : handleFirstCall(nextState, nextOwnProps)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们看到, connect 生成了一个selector函数, 通过保存 <code>mapStateToProps</code> <code>mapDispatchToProps</code>的返回值,对两次结果进行比较来做优化,如果没变化则直接返回旧值.这样我们在每次调用selector之后,只要两次的返回值相等, 则说明我们并不需要渲染, 那么connectHOC的 <code>componentShouldUpdate</code>就可以返回true了<br>所以只要我们生成了select函数, 剩下只需要关注状态变化, 并渲染就可以了</p>
<h4 id="state状态改变通知"><a href="#state状态改变通知" class="headerlink" title="state状态改变通知"></a>state状态改变通知</h4><p>再看代码前, 我们先来想一想应该怎样做状态变化的通知.</p>
<p>一种比较简单的状态通知方式是, 每次store改变, 触发根组件的刷新, 所有的connect都会在reRender的时机通过<code>context</code>取获取最新的全局state, 并通过selector进行属性提取, 最后把对应的props注入组件中</p>
<p>但是这有一个问题, 首先就是这种方式会在每次store有变化时,进行一次全应用的reRender, 性能可以说是非常差了. 所以要做性能优化, 上一节我们说了, 设计出来的selector是具被这些能力的,只需要使用<br><code>componentShouldUpdate</code>优化, 使用它来判断是否需要对组件进行渲染.</p>
<p>但是如果我们仔细想一下,有任何一个connectHOC再做过前后stateProps对比后, 发现没有变化, 那么它就会停止了渲染, 这样会发生什么? 无疑, 这会导致 下级的connect<br>没有触发reRender, 从而也就不会触发它获取最新store, 整个数据的传递,再这里就被截断了, 在新的context api出现之前, 这个问题一直是倍受开发者诟病</p>
<p>上面这种方式状态的更新路径可以见下图;<br><img src="https://moka-sugar.oss-cn-beijing.aliyuncs.com/img/react-redux1.png" alt></p>
<p>既然有这样的问题, 我们就需要考虑能不能不让所有的connect去直接依赖store的变化? 如果这样,我们应该怎么办?</p>
<p>我们是不是可以通过嵌套层级进行一级一级的传递, 当顶级的store改变了, 向下一级进行通知, 对应的connect会自动向下一级进行转发, 这样就不再依赖于组件的渲染传递了, 具体的示意图如下:</p>
<p><img src="https://moka-sugar.oss-cn-beijing.aliyuncs.com/img/2222.png" alt></p>
<p>实际上<code>react-redux</code>就是这样解决问题的, 每一个connectHOC都是一个订阅者, 同时也是一个发布者, 他们都包含一个<code>subscription</code>对象, 用来订阅上级connect, 并且通知下级connect,接下来上代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对select进行一次包裹, 方便吧一些值保存在这个包裹对象里</span></span><br><span class="line"><span class="comment">// 除了run, 还有props用来记录当前最新的stateProps, 还有shouldComponentUpdate</span></span><br><span class="line"><span class="comment">// 用来记录下次reRender是否应该通过</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSelectorStateful</span>(<span class="params">sourceSelector, store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> selector = &#123;</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> <span class="title">runComponentSelector</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> nextProps = sourceSelector(store.getState(), props)</span><br><span class="line">      <span class="keyword">if</span> (nextProps !== selector.props) &#123;</span><br><span class="line">        selector.shouldComponentUpdate = <span class="literal">true</span></span><br><span class="line">        selector.props = nextProps</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> selector</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真正的connect包裹组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props, context)</span><br><span class="line">    <span class="keyword">this</span>.store = context.store</span><br><span class="line">    <span class="keyword">this</span>.initSelector() <span class="comment">// 初始化selector</span></span><br><span class="line">    <span class="keyword">this</span>.initSubscription() <span class="comment">// 初始化订阅器</span></span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="comment">// 覆盖上级的context, 这样下级的ConnectHOC就会获取覆盖后的订阅器,</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">storeSubscription</span>: <span class="keyword">this</span>.subscription &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscription.trySubscribe()</span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props) <span class="comment">// 计算当前最新的props</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.selector.shouldComponentUpdate) <span class="keyword">this</span>.forceUpdate() <span class="comment">// 如果计算结果有变化就强制刷新</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector.run(nextProps) <span class="comment">// 每次获取到新的props都从新进行计算</span></span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selector.shouldComponentUpdate</span><br><span class="line">  &#125;</span><br><span class="line">  initSelector() &#123;</span><br><span class="line">    <span class="comment">// 初始化selector, 这里的selector, 就是我们上面提到的selector, 接受最新的全局State, 和当前组件的props</span></span><br><span class="line">    <span class="keyword">const</span> sourceSelector = selectorFactory(<span class="keyword">this</span>.store.dispatch, selectorFactoryOptions)</span><br><span class="line">    <span class="comment">// 做一个包裹, 用来保存更多信息</span></span><br><span class="line">    <span class="keyword">this</span>.selector = makeSelectorStateful(sourceSelector, <span class="keyword">this</span>.store)</span><br><span class="line">    <span class="comment">// 调用run, 等于直接调用selector, 获取最新的props</span></span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line">  &#125;</span><br><span class="line">  initSubscription() &#123;</span><br><span class="line">    <span class="keyword">const</span> parentSub =  <span class="keyword">this</span>.context[subscriptionKey] <span class="comment">// 获取上一级的订阅器</span></span><br><span class="line">    <span class="comment">// 再上一级订阅器里注册onStateChange回调, 并生成自己的订阅器</span></span><br><span class="line">    <span class="comment">// 之前卖的关子就在这里, Provider传入的 context.storeSubscription 是null, 因为当 storeSubscription为空的话, connect的会直接到store上进行订阅</span></span><br><span class="line">    <span class="comment">// 否则会在上级connect再context中传入storeSubscription上进行订阅</span></span><br><span class="line">    <span class="comment">// 也就是说, 只有第一级connect会直接订阅store的变化, 其他级别都是直接订阅上级connect的storeSubscription</span></span><br><span class="line">    <span class="keyword">this</span>.subscription = <span class="keyword">new</span> Subscription(<span class="keyword">this</span>.store, parentSub, <span class="keyword">this</span>.onStateChange.bind(<span class="keyword">this</span>))</span><br><span class="line">    <span class="keyword">this</span>.notifyNestedSubs = <span class="keyword">this</span>.subscription.notifyNestedSubs.bind(<span class="keyword">this</span>.subscription)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个方法会在每次store有变化时调用</span></span><br><span class="line">  onStateChange() &#123;</span><br><span class="line">    <span class="comment">// 首先是计算props</span></span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.selector.shouldComponentUpdate) &#123;</span><br><span class="line">      <span class="comment">// 无变动则只通知</span></span><br><span class="line">      <span class="keyword">this</span>.notifyNestedSubs()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 有变动则再下次didupdate的时候进行通知, 我猜测是为了防止一次出发所有变动导致性能卡顿???</span></span><br><span class="line">      <span class="keyword">this</span>.componentDidUpdate = <span class="keyword">this</span>.notifyNestedSubsOnComponentDidUpdate</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// didUpdate生命周期的实际回调函数, 这么做官方解释也是为了能够减少boolean判断, 提高性能</span></span><br><span class="line">  notifyNestedSubsOnComponentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">this</span>.componentDidUpdate = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.notifyNestedSubs()</span><br><span class="line">  &#125;</span><br><span class="line">  isSubscribed() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Boolean</span>(<span class="keyword">this</span>.subscription) &amp;&amp; <span class="keyword">this</span>.subscription.isSubscribed()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> selector = <span class="keyword">this</span>.selector</span><br><span class="line">    selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> createElement(WrappedComponent,selector.props)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>OK, 看完这些, 我们基本上就把<code>react-redux</code>的核心理念都看完了, </p>
<ol>
<li>首先是生成一个selector函数, 截取需要数据进行前后对比, 确定是否rerender</li>
<li>为了保证不被<code>componentShouldUpdate</code>截断, 使用发布订阅模式来对子级<code>connect</code>进行通知</li>
</ol>
<p>上述的代码都是为了方便阅读而做了大量的删减, 只保存了最关键的代码, 实际上还有一些报错处理, 以及兼容处理, 比如如何应对一些react16已经不在安全的生命周期兼容,<br>ssr场景兼容, 以及更多的可扩展性的设计, 对了, 还有很多高阶函数的骚气调用, 看得我眼花缭乱. 总体来说, 收获不少, 能更深刻的理解设计者, 了解到他们代码之下的思考.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/19/你真的知道react-redux是怎么运行的么/" data-id="ckd5eq8ev0007tproc8g3olj6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何设计一个简单的模块系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/如何设计一个简单的模块系统/" class="article-date">
  <time datetime="2020-04-27T13:53:54.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/如何设计一个简单的模块系统/">如何设计一个简单的模块系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前端社区早在几年前就进到了模块化开发方式中了, 实际上es6之前, js是没有模块概念的. 既没有变量的导出, 也没有变量的引入. </p>
<p>随着前端需要承担的功能越来越繁重, 需要复用的逻辑也越来越多, 全局变量越来越容易碰撞, 前端急需一个模块化方案. 那么既然<code>javascript</code>语言本身并没有模块化功能, 但是大佬们必然是有办法的. 于是各种模块化方案分分出现<code>CMD</code> <code>AMD</code> <code>CommonJS</code>, 再es6规范出来前, 这三种方案几乎统治了所有<code>javascript</code>开发. 他们都在自己不同的领域他提出了实现方案, 并解决了诸多的问题.</p>
<p>没想到的是, 前端是在变化太快, 2015年es6发布, 从此<code>javascript</code>有了自己的模块化方案. 并且很快, 基于模块化的打包工具<code>webpack</code>发布, 把前端工程化拉上一个全新高度—-万物皆模块.<br>善于接受变化的前端社区统统拥抱<code>webpack</code>, 很快<code>webpack</code>天下大统, 之前的三大解决方案,除了<code>commonJS</code>因为<code>NodeJS</code>亲儿子的高贵血统, <code>CMD</code> <code>AMD</code>的两个方案<code>require.js</code> <code>sea.js</code>几乎已经告别江湖, 成为历史, 变成了老前端回忆自己峥嵘岁月的谈资了. 是不是很像<code>jquery</code>的经历?</p>
<p>既然<code>webpack</code>这么厉害, 那么他的打包方案是什么? 是<code>esModule</code>么?</p>
<h3 id="webpack时代"><a href="#webpack时代" class="headerlink" title="webpack时代"></a>webpack时代</h3><p>实际上由于webpack是基于<code>NodeJs</code>的运行时, 所以webpack显然一开始是使用的<code>commonJS</code>的方案, 相比<code>CMD</code> <code>AMD</code>,<code>commonJS</code>的群体比较大, 因为是运行再<code>NodeJS</code>上, <code>webpack</code>的配置文件,plugin,loader,都必须使用<code>commonJS</code>的方式来引入, 所以其他代码如果都是用一套方案,这样也比较统一, 也符合直觉. </p>
<p>虽然webpack再js代码的模块加载是按照<code>commonJS</code>规范来的, 但是实际上由于打包后的代码是运行再前端的, 所以需要实现一个前端的模块加载运行时, 那么webpack到底是怎么让基于<code>nodeJS</code>的模块系统再打包后能成功运行再前端呢?</p>
<h3 id="如何实现一个模块"><a href="#如何实现一个模块" class="headerlink" title="如何实现一个模块"></a>如何实现一个模块</h3><p>理想的一个js module应该是有自己的环境, 模块之间互相无法影响, 相互见的全局变量都是不可见的. 并且模块需要可以导出数据, 还要能够加载其他模块导出的数据.那么这样的功能我们该如何实现呢?</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们先定义两个三个文件, 互相加载一下:</p>
<p><em>/index.js</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./dep.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure></p>
<p><em>/dep.js</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./common.js'</span>)</span><br><span class="line"><span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = funA;</span><br></pre></td></tr></table></figure></p>
<p><em>/common.js</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = util;</span><br></pre></td></tr></table></figure></p>
<p>他们的依赖关系如下: <code>index.js</code> -&gt; <code>dep.js</code> -&gt; <code>common.js</code>;</p>
<p>好了, 既然上面的示例已经定好了, 使用的是<code>commonJS</code>的规范, 既然我们要实现一个简单版的模块系统, 那么先来分析分析这里会用到的语法把</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import 代码</span></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// export 导出代发方式1</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  funA</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// or 导出代码方式2</span></span><br><span class="line">exports.funcA = funA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的两种导出方式是等价的</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码,我们可以看到, 这里有三个全局变量<code>require</code> <code>module</code> <code>exports</code>, 这三个全局变量我们待会再说</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>ok, 既然是模块, 首先需要考虑的就是隔离全局变量, 换而言之就是要让每一个模块的执行环境都在不同的作用于下,<br>那么如何形成新的作用于我就不多说了,只要使用一个函数把模块中的代码进行包裹就可以了,就像这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line">  <span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">// export</span></span><br><span class="line">  <span class="built_in">module</span>.exports = funA;</span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  exports.funA = funA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样模块內的全局变量就都变成了这个函数的局部变量, 现在只需把全局变量通过模块的函数参数传入, 那么接下来我们需要解决两个问题:</p>
<ul>
<li>如何把所有的模块都改写成包裹函数的方式, 并且把这些函数找个地方统一管理起来</li>
<li>如何实现<code>require</code> 和 <code>module</code> <code>exports</code> 这三个变量</li>
</ul>
<h3 id="解析依赖树"><a href="#解析依赖树" class="headerlink" title="解析依赖树"></a>解析依赖树</h3><p>第一个问题, 可以参考我之前的文章, 使用<code>babel</code>来解析入口文件<code>index.js</code></p>
<p>因为在解析过程中, 我们需要获取所有的模块, 并且生成这个模块的唯一id, 方便起见, 我们直接已模块的项目相对路径为key来记录</p>
<p>整个过程大概分下面几部:</p>
<ol>
<li>从入口未见解析, 只要遇到require方法的调用, 就解析他的参数来读取对应的模块文件, 并修改require的参数为require文件的项目相对路径</li>
<li>记录下文件的路径, 并js文件字符串,对其进行包裹</li>
<li>递归的重复上面两步解析js直到获取所有的依赖文件.</li>
<li>遍历后生成一个路径到模块的mapping即可, 生成后的模块图大概如此<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadedModulesMap = &#123;</span><br><span class="line">  <span class="string">'src/dep.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'src/common.js'</span>)</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'src/common.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123; <span class="comment">/* code */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="实现require"><a href="#实现require" class="headerlink" title="实现require"></a>实现require</h3><p>解决第二个问题, 码字太麻烦, 直接上代码把</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里记录的是第一步解析出来的所有依赖文件</span></span><br><span class="line"><span class="keyword">const</span> loadedModulesMap = &#123;</span><br><span class="line">  <span class="string">'src/dep.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'src/common.js'</span>)</span><br><span class="line">    <span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports = funA;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'src/common.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> util = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports = util; </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 缓存, 防止重复加载相同的模块</span></span><br><span class="line"><span class="keyword">const</span> cacheModulesMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义require方法</span></span><br><span class="line"><span class="built_in">require</span>(path) &#123;</span><br><span class="line">  <span class="comment">// 先走缓存</span></span><br><span class="line">  <span class="keyword">if</span> (cacheModulesMap[path]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheModulesMap[path].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册缓存, 拿到缓存上的引用指针</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = cacheModulesMap[path] = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line">  <span class="comment">// 去模块map里拿对应的模块</span></span><br><span class="line">  <span class="keyword">const</span> modulesFn = loadedModulesMap.path;</span><br><span class="line">  <span class="comment">// 执行模块, 这里要注意, 模块的导出值灰写入的module上, 由于module是</span></span><br><span class="line">  <span class="comment">// cacheModulesMap的引用, 所以导出值都会同时被保存</span></span><br><span class="line">  modulesFn(<span class="built_in">require</span>, <span class="built_in">module</span>, <span class="built_in">module</span>.exports );</span><br><span class="line">  <span class="comment">// module已经拿到导出值了, 直接返回对应导出值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.export;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行入口文件代码, 一切慢慢展开</span></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'src/dep.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>这样, 一个解析后的代码, 就可以被正常的运行了, 这里我们可以发现一个<code>commonJS</code>模块的一个特点, 就是模块的加载是在运行时完成的, 也就是说, 只有在代码运行的时候, 模块才会被加载, 并且加载顺序和代码的调用顺序是强关联的, 这个和esModule是不同的, 感兴趣的同学可以去了解一下两者之间的区别</p>
<h3 id="异步require"><a href="#异步require" class="headerlink" title="异步require"></a>异步require</h3><h4 id="异步模块数据结构"><a href="#异步模块数据结构" class="headerlink" title="异步模块数据结构"></a>异步模块数据结构</h4><p>上面是我们普通的require模块的简单实现. 但是在脱离的<code>node</code>环境后, 前端资源实际上很大程度上是依赖于异步获取的,那么一个需要异步获取的模块应该设计成什么样呢? 看看下面的数据结构;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">`src/async.js`</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asyncFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports = funA;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构保留了我们上面<code>loadedModulesMap</code>的数据结构, 方便merge到里面去, 现在需要设计一种加载机制, 把这部分代码加载到<code>loadedModulesMap</code>里</p>
<h4 id="主代码如何加载异步代码"><a href="#主代码如何加载异步代码" class="headerlink" title="主代码如何加载异步代码"></a>主代码如何加载异步代码</h4><p><code>webpack</code>实现了一种异步加载的方法<code>require.ensure</code>, 我们就沿用把, 只不过既然是简单版, 就一个参数吧! 我们让<code>dep.js</code>变成异步加载common.js</p>
<p><em>/dep.js</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./common.js'</span>)</span><br><span class="line"><span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = funA;</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>.ensure(<span class="string">'./common.js'</span>).then(<span class="function">(<span class="params">util</span>) =&gt;</span> &#123;</span><br><span class="line">  util.xxx();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = funA;</span><br></pre></td></tr></table></figure></p>
<h4 id="异步模块设计"><a href="#异步模块设计" class="headerlink" title="异步模块设计"></a>异步模块设计</h4><p>有一点可以肯定, 我们肯定不能使用Ajax的方式进行, 因为我们需要执行它, 所以我们选择使用script标签, 那么只有一条路了! JSONP!</p>
<p><em>异步模块</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两边定义一个共有变量 JSON_LIST</span></span><br><span class="line"><span class="comment">// 异步模块在加载后直接执行, 把模块挂载的全局队列里, 等待主模块读取</span></span><br><span class="line"><span class="built_in">window</span>.JSONP_LIST.push(</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">`src/async.js`</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> asyncFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports = funA;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><em>主模块</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义异步加载模块的方法</span></span><br><span class="line"><span class="built_in">require</span>.ensure = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 说明异步模块没加载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否加载过了</span></span><br><span class="line">    <span class="keyword">if</span> (!loadedModulesMap[path]) &#123;</span><br><span class="line">      resolve(<span class="built_in">require</span>(path));</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义script标签</span></span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    <span class="comment">// 全局公共路径 + 相对路径拼接请求, 简单处理啦!</span></span><br><span class="line">    <span class="keyword">var</span> url = PUBLIC_PATH + path;</span><br><span class="line">    script.url = url;</span><br><span class="line">    <span class="comment">// 定义加载完成后的成功回调</span></span><br><span class="line">    script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 模块请求成功后, 加载队列里的所有模块</span></span><br><span class="line">      <span class="built_in">window</span>.JSONP_LIST.forEach(<span class="function">(<span class="params">moduleObj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(moduleObj).forEach(<span class="function">(<span class="params">_path</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!loadedModulesMap[_path]) &#123;</span><br><span class="line">            loadedModulesMap[_path] = moduleObj[_path];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="comment">// 处理了JSON_LIST里面已经加载郭的模块就要清空</span></span><br><span class="line">      <span class="built_in">window</span>.JSON_LIST = [];</span><br><span class="line">      <span class="comment">// 这时 已经成功加载了异步模块, 这时候返回模块值</span></span><br><span class="line">      <span class="keyword">if</span> (!loadedModulesMap[path]) &#123;</span><br><span class="line">        resolve(<span class="built_in">require</span>(path));</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="一些其他细节"><a href="#一些其他细节" class="headerlink" title="一些其他细节"></a>一些其他细节</h4><p>在增加了<code>require.ensure</code>之后, 你需要在解析文件的时候考虑异步加载的情况:</p>
<ul>
<li>解析<code>require.ensure</code>的调用</li>
<li>异步应依赖的子树单独生成异步模块文件</li>
</ul>
<p>最后生成的代码应该是:</p>
<p>主文件<em>main.js</em>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadedModulesMap = &#123;</span><br><span class="line">  <span class="string">'src/dep.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleA = <span class="built_in">require</span>.ensure(<span class="string">'src/common.js'</span>)</span><br><span class="line">    <span class="keyword">var</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports = funA;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cacheModulesMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cacheModulesMap[path]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheModulesMap[path].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = cacheModulesMap[path] = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line">  <span class="keyword">const</span> modulesFn = loadedModulesMap.path;</span><br><span class="line">  modulesFn(<span class="built_in">require</span>, <span class="built_in">module</span>, <span class="built_in">module</span>.exports );</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.export;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.ensure = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!loadedModulesMap[path]) &#123;</span><br><span class="line">      resolve(<span class="built_in">require</span>(path));</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    <span class="keyword">var</span> url = PUBLIC_PATH + path;</span><br><span class="line">    script.url = url;</span><br><span class="line">    script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.JSONP_LIST.forEach(<span class="function">(<span class="params">moduleObj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(moduleObj).forEach(<span class="function">(<span class="params">_path</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!loadedModulesMap[_path]) &#123;</span><br><span class="line">            loadedModulesMap[_path] = moduleObj[_path];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="built_in">window</span>.JSON_LIST = [];</span><br><span class="line">      <span class="keyword">if</span> (!loadedModulesMap[path]) &#123;</span><br><span class="line">        resolve(<span class="built_in">require</span>(path));</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'src/dep.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure></p>
<p>异步文件<em>src/common.js</em>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.JSONP_LIST.push(</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">`src/common.js`</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> util = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports = util;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上只是一个非常非常简单的模块加载系统, 玩具中的玩具, 但是这不妨碍我们理解<code>js</code>模块化的本质, 只要看明白本质, 实际上<code>webpack</code>那些<br>眼花缭乱的操作也就不再那么神奇了</p>
<p>如果之后有机会, 我也许会在这个篇文章里补全简易版的webpack module federation, 敬请期待……</p>
<p>也许是后会无期?(大笑😄,逃……)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/27/如何设计一个简单的模块系统/" data-id="ckd5eq8ex000atproink5bt3a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何设计一个插件系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/29/如何设计一个插件系统/" class="article-date">
  <time datetime="2020-03-29T12:02:23.000Z" itemprop="datePublished">2020-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/29/如何设计一个插件系统/">如何设计一个插件系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端的日常开发, 离不开众多由社区提供的第三方library, 从创建到项目打包再到代码的运行时统统都少不了它们的身影. 我们再使用他们的时候由于不同的业务需求,有时候需要对他们进行一些修改. 而设计优秀的的library通常都有一些方式对使用者提供扩展的能力, 这种提供扩展能力的方法通常叫做插件</p>
<p>说到插件大家应该都不陌生, 几乎再日常开发中能用到形形色色的插件, 比如webpack的plugin, babel的plugin, 或者是eslint的plugin, 又或者是vue的plugin,甚至是很多coder都在使用的vscode的extend等等, 数不胜数. 那么这些优秀的项目的扩展体系都是如何设计的? 他们又为什么这么设计? 我们能从这当中学习到什么? 接下来我将从一个简单的小功能作为例子,以一个library开发者的角度来考虑, 一个插件系统应该如何设计.</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>一下是一个非常简单功能例子, 就叫他miniLibrary吧! 它的执行顺序十分简单: 输入数据 -&gt; 数据处理 -&gt; 渲染数据:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProcessRender</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(a, b, targetDom) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state &#123;</span><br><span class="line">      a,</span><br><span class="line">      b,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.targetDom = targetDom;</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.state.targetDom).innerHtml = process(<span class="keyword">this</span>.state.a, <span class="keyword">this</span>.state.b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> render = <span class="keyword">new</span> DateProcessRender()</span><br><span class="line">render.apply(<span class="string">'hello'</span>, <span class="string">' world!!'</span>, <span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure></p>
<p>显然目前看来, 这个library不仅很简单, 而且根本没有任何扩展可言, 除了能够修改<code>apply</code>方法的参数以外, 我们什么也做不了, 那么如果我们想给他增加扩展能力,我们应该怎么办呢?</p>
<h2 id="插件的引入"><a href="#插件的引入" class="headerlink" title="插件的引入"></a>插件的引入</h2><p>首先我们需要设计一个插件引用的方式, 插件的引入一般有两种方法, 一种是通过配置声明的方式引入, 比如webpack, babel都是这样的, 使用的是它们的config文件来引入:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugin: [<span class="string">'upperCase-param'</span>, <span class="string">'default-render'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种是vue这种调用式的加载方式:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(xxx)</span><br></pre></td></tr></table></figure></p>
<p>实际上第一个和第二个者没有本质区别, 最后还是会已第二种的形式对插件进行引入,那么既然两者实际上都一样, 那么我们就需要自己去实现一个插件的加载器功能</p>
<p>插件加载器一般分成插件的加载和插件的调用两个部分, 插件的加载很简单, 无非就是一个方法把插件注入到Library的内部, 方便随时调用, 但是插件的调用确非诚的依赖插件系统的本身设计, 所以我们我们先看看插件系统通常都有哪些把!</p>
<h2 id="常见插件系统分类"><a href="#常见插件系统分类" class="headerlink" title="常见插件系统分类"></a>常见插件系统分类</h2><p>通常插件系统的分类有: </p>
<ul>
<li>事件钩子型 </li>
<li>pipeline的流式调用型</li>
<li>获取实例型</li>
</ul>
<p>那么下面我们分别按三种方式来对我们的这个这个miniLibrary进行插件化吧!</p>
<h2 id="事件钩子型"><a href="#事件钩子型" class="headerlink" title="事件钩子型"></a>事件钩子型</h2><p><em>使用钩子插件系统的Library有很多, <code>webpack</code> <code>babel</code>都是</em></p>
<p>从代码上看, 程序执行有几个主要的运行阶段: <code>apply</code> <code>process</code> <code>render</code> 我们只需要在这几个地方增加生命周期函数, 就可以吧把扩展的能力给到外面了,而你需要定义的就是每个钩子函数能拿到什么参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProcessRender</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.plugin = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process(a, b) &#123;</span><br><span class="line">    <span class="comment">// 增加process钩子, 用于增加处理结果的扩展能力</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.plugin?.process?.(a, b) || a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(a, b, targetDom) &#123;</span><br><span class="line">    <span class="comment">// apply钩子, 可以扩展初始化数据</span></span><br><span class="line">    <span class="keyword">const</span> [_a, _b, _targetDom] = <span class="keyword">this</span>.plugin?.onApply?.(a, b, targetDom);</span><br><span class="line">    <span class="keyword">this</span>.state &#123;</span><br><span class="line">      a: _a,</span><br><span class="line">      b: _b,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.targetDom = _targetDom;</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// runder钩子, 用于修改render的节点</span></span><br><span class="line">    <span class="keyword">const</span> dom = <span class="keyword">this</span>.plugin?.onRender?.(<span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.state.targetDom), <span class="keyword">this</span>.targetDom);</span><br><span class="line">    dom.innerHtml = process(<span class="keyword">this</span>.state.a, <span class="keyword">this</span>.state.b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  use(plugin) &#123;</span><br><span class="line">    <span class="keyword">this</span>.plugin = plugin;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plugin = &#123;</span><br><span class="line">  onApply: <span class="function">(<span class="params">a ,b ,targetDom</span>) =&gt;</span> [a.toUpperCase(), b.toUpperCase(), targetDom];</span><br><span class="line">  onProcess: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + <span class="string">' '</span> + b + <span class="string">' some extend text'</span>;</span><br><span class="line">  onRender: <span class="function">(<span class="params">dom</span>) =&gt;</span> dom || <span class="built_in">document</span>.querySelector(<span class="string">'#defaultDom'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> render = <span class="keyword">new</span> DateProcessRender()</span><br><span class="line">render.use(plugin);</span><br><span class="line">render.apply(<span class="string">'hello'</span>, <span class="string">' world!!'</span>, <span class="string">'#app'</span>); <span class="comment">// HELLO WORLD!! some extend text</span></span><br></pre></td></tr></table></figure></p>
<p>以上这种是使通过不同的周期函数来把新的逻辑值入到对应的阶段, 再不同的阶段对数据做不同程度的修改, 这看上去是不是很像写react组件?实际上你也可以吧每一个react的component看成react的插件, 而React只是一个调用器</p>
<p>这种设计插件的方式属于典型的声明式的编程, 代码的可读性比较强, 很容易再阅读插件源码的时候搞清楚来龙去脉, 并且对插件的能力做出了有效的控制. 不过对插件能力的控制试一把双刃剑, 及减少了不良插件对library的影响, 也同时代表插件的扩展能力没有那么强大</p>
<h2 id="pipeline的流式调用型"><a href="#pipeline的流式调用型" class="headerlink" title="pipeline的流式调用型"></a>pipeline的流式调用型</h2><p><em>使用pipeline的方式来进行扩展, 典型的应用有webpack loader 和 express的中间件.</em></p>
<p>一次调用一个plugin, 以类似流水线的方式击鼓传花对数据进行操作, 最后对数据做出响应的扩展方案, 一个个关联看似不大的插件, 就这么组合出一个强大的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProcessRender</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.plugins = []; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(a, b, targetDom) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state &#123;</span><br><span class="line">      a,</span><br><span class="line">      b,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.targetDom = targetDom;</span><br><span class="line">    run();</span><br><span class="line">  &#125;</span><br><span class="line">  process() &#123;</span><br><span class="line">    data.result = data.a + <span class="string">''</span> + data.b; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.state.targetDom).innerHtml(<span class="keyword">this</span>.state.result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">this</span>.process();</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> context = &#123;</span><br><span class="line">      data: <span class="keyword">this</span>.state;</span><br><span class="line">      targetDom: <span class="keyword">this</span>.targetDom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里只支持了同步的调用</span></span><br><span class="line">    <span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> plugins.length &lt; index + <span class="number">1</span> ? <span class="keyword">this</span>.plugins[index](context, next);</span><br><span class="line">    <span class="comment">// 依次调用插件, 进行数据处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.plugins.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.plugins[index](context, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  use(plugin) &#123;</span><br><span class="line">    <span class="keyword">this</span>.plugins.push(plugin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginA = <span class="function">(<span class="params">context, next</span>) =&gt;</span>  &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = context;</span><br><span class="line">  data.a = data.a.toUpperCase(); </span><br><span class="line">  data.b = data.a.toUpperCase(); </span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginB = <span class="function">(<span class="params">context, next</span>) =&gt;</span>  &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = context;</span><br><span class="line">  data.result =  data.a + <span class="string">' '</span> + dat.b + <span class="string">' some extend text'</span>;</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginC = <span class="function">(<span class="params">context, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">document</span>.querySelector(contest.targetDom)) &#123;</span><br><span class="line">    context = <span class="string">'#defaultDom'</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="keyword">new</span> DateProcessRender()</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">render.use(pluginA);</span><br><span class="line">render.use(pluginB);</span><br><span class="line">render.use(pluginC);</span><br><span class="line">render.apply(<span class="string">'hello'</span>, <span class="string">' world!!'</span>, <span class="string">'#app'</span>); <span class="comment">// HELLO WORLD!! some extend text</span></span><br></pre></td></tr></table></figure></p>
<p>上面故意多些几个例子是为了让每个插件的职责单一, 实际上这也着这类pipeline插件的特点, 比较容易写出职责单一的插件, 方便在后续的使用中进行有效的组合已经复用. 同时这种方式也能比较好的控制住插件的能力,你只需要把希望插件控制的属性传给他即可</p>
<h2 id="获取实例型"><a href="#获取实例型" class="headerlink" title="获取实例型"></a>获取实例型</h2><p><em>获取实例的插件系统也有很多Library在使用, <code>jQuery</code> <code>Vue</code></em><br>获取实例的方式, 可以让插件直接拿到Library的实例, 也就以为这他能拿到几乎所有的数据, 和直接改源码效果差不多, 非常的强大粗暴<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProcessRender</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(a, b, targetDom) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state &#123;</span><br><span class="line">      a,</span><br><span class="line">      b,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.targetDom = targetDom;</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.state.targetDom).innerHtml = process(<span class="keyword">this</span>.state.a, <span class="keyword">this</span>.state.b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  use(plugin) &#123;</span><br><span class="line">    plugin(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plugin(instance) &#123;</span><br><span class="line">  instance.process = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.toUpperCase() + <span class="string">' '</span> + b.toUpperCase() + <span class="string">' some extend text'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  instance.render() &#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.state.targetDom) || <span class="built_in">document</span>.querySelector(<span class="string">'#defaultDom'</span>)</span><br><span class="line">    dom.innerHtml = process(<span class="keyword">this</span>.state.a, <span class="keyword">this</span>.state.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="keyword">new</span> DateProcessRender()</span><br><span class="line">render.use(pluginA);</span><br><span class="line">render.apply(<span class="string">'hello'</span>, <span class="string">' world!!'</span>, <span class="string">'#app'</span>); <span class="comment">// HELLO WORLD!! some extend text</span></span><br></pre></td></tr></table></figure></p>
<p>这种方法显然是这三种当中最直接粗暴的策略, 给插件提供了非常非常强大的能力, 用这种方式, 你可以用很多种实现我们需要的功能, 但是强大的能力带给我们的是更多的风险. 我们需要去小心插件产生的副作用以及更陡峭的插件开发学习曲线. 因为你可以获得整个实例的所有数据. 你不仅仅可以读取实例所有数据, 你还可以给实例增加新的方法和属性, 但是这都需要又一个前提, 你对library的源码要了解的足够多, 以防你不小心覆盖了library的原生方法和属性导致了未知的错误</p>
<p>同时虽然有很好的扩展能力, 但是多个插件之间非常不容易相互配合, 并且插件的编写没什么解构调理, 让阅读代码上让人感到吃力</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>首先得说明一下, 上面的例子都非常的简陋, 只是为了说明概念而设计的, 实际上的正规项目, 这些方案会复杂很多, 这里仅仅作为抛砖引玉.</p>
<p>那么问题来了, 以上三种插件模式到底哪一种好? 在我看来他们各有各的特点, 没有办法说出具体哪个好, 只能是各有千秋, 以及能力上的取舍而已, 实际上社区里的各大Library也并非是同时只在使用一个模式, 他们往往是相互使用的, 可能同时存在及使用钩子, 又使用继承, 既使用继承, 又使用pipeline. 比如webpack,他就是把这三种方式进行了融合, 感兴趣的同学可以看我之前的博文.</p>
<p>回到开头的问题上来, 我们能从这些插件系统模式上学到什么? 我觉得是让一个个看似黑箱的Library更加透明, 让写一个插件感觉并没有那么云里雾里, 让我们在写代码的时候能够知其然也能知其所以然.</p>
<h2 id="银弹"><a href="#银弹" class="headerlink" title="银弹?"></a>银弹?</h2><p>插件系统的设计有没有银弹呢? 我觉得没有, 但是会有一些很好的实践. </p>
<p>目前很多Library的插件系统做的都十分底层, 并不是简简单单中来做功能扩展的, 而是一个完整的运行架构. 所以的library内置功能都是基于插件来开发的, 比如babel-core 只是做代码到ast再到代码的转换, 大概是这样: <code>(a) =&gt; a</code>, 所有的语法转换都是基于一个个的插件来进行特定语法的转移<br>还有就是webpack的构建运行时, 从构建启动, 到文件生成, 都是一系列的声明周期钩子的调用.几乎95%的打包实现都是由不同的插件来实现的. </p>
<p>可以吧babel-core webpack-runtime 想象成我们开发使用的react, 所谓的Library功能, 就是我们写的react项目, 可以说功能插件化这是未来大型Library设计趋势, </p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>插件系统应该还有很多其他的方法论, 如果我在之后又看到新鲜的方案, 会第一时间分享出来.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/29/如何设计一个插件系统/" data-id="ckd5eq8ex0009tpro0m3r44wz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入webpack-插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/31/深入webpack-插件/" class="article-date">
  <time datetime="2020-01-31T02:11:46.000Z" itemprop="datePublished">2020-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/31/深入webpack-插件/">深入webpack-插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>webpack</code>目前是前端打包工具使用最多的工具, 这不仅仅是因为它有非常好的打包性能, 还应为它具备非常强的扩展性,可以为不同的场景进行功能的扩展.</p>
<p>如果我们去浏览一下<code>webpack</code>的源码, 我们会发现<code>webpack</code>源码里有了非常非常多的插件,在看过一部分<code>webpack</code>源码后你会发现, 实际上<code>webpack</code>的所有功能都是用一个一个插件堆砌出来的.下面我们先讲一讲<code>webpack</code>插件的核心逻辑到底是什么.</p>
<h2 id="打包的主要流程"><a href="#打包的主要流程" class="headerlink" title="打包的主要流程"></a>打包的主要流程</h2><p>我们把<code>webpack</code>的构建过程想象成是一个有大量生命周期的一个MVVM前端组件, 从组件初始化到成功的渲染的页面上会触发多个生命周期, 在不同的生命周期来会触发不同的回调函数,而回调函数可以访问到组件的内部状态.</p>
<p><code>webpack</code>在每一次构建的时候会生成一个<code>compiler</code>对象, 这个对象就类似于一个组件实例, 所有的生命周期都是对这个<code>compiler</code>对象的状态描述.<code>compiler</code>对象会依次触发它上面的每一个生命周期, 只不过在<code>webpack</code>里我们不叫它生命周期, 叫做<strong>钩子</strong></p>
<p><code>webpack</code>里所有的对象几乎都是由类来生成的, 而钩子就是在类的<code>constructor</code>方法中进行初始化. 看过上一篇对tapable介绍的同学应该知道, 这里在大概说一下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(context) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hook = &#123;</span><br><span class="line">      <span class="comment">/** @type &#123;SyncBailHook&lt;[string, Entry], boolean&gt;&#125; 处理webpack config option */</span></span><br><span class="line">      entryOption: <span class="keyword">new</span> SyncBailHook([<span class="string">"context"</span>, <span class="string">"entry"</span>])</span><br><span class="line">      <span class="comment">/** @type &#123;AsyncSeriesHook&lt;[Compiler]&gt;&#125; 正式开始 */</span></span><br><span class="line">      run: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]),</span><br><span class="line">      <span class="comment">/** @type &#123;SyncHook&lt;[CompilationParams]&gt;&#125; 编译 */</span></span><br><span class="line">      compile: <span class="keyword">new</span> SyncHook([<span class="string">"params"</span>]),</span><br><span class="line">      <span class="comment">/** @type &#123;SyncHook&lt;[Compilation, CompilationParams]&gt;&#125; 生成 compilation */</span></span><br><span class="line">      compilation: <span class="keyword">new</span> SyncHook([<span class="string">"compilation"</span>, <span class="string">"params"</span>]),</span><br><span class="line">      <span class="comment">/** @type &#123;AsyncParallelHook&lt;[Compilation], Module&gt;&#125; 生成依赖树 */</span></span><br><span class="line">      make: <span class="keyword">new</span> AsyncParallelHook([<span class="string">"compilation"</span>]),</span><br><span class="line">      <span class="comment">/** @type &#123;AsyncSeriesHook&lt;[Compilation]&gt;&#125; 写入文件系统 */</span></span><br><span class="line">      emit: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compilation"</span>]),</span><br><span class="line">      <span class="comment">/** @type &#123;AsyncSeriesHook&lt;[Stats]&gt;&#125; 完成 */</span></span><br><span class="line">      done: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"stats"</span>]),</span><br><span class="line">      <span class="comment">/** @type &#123;SyncHook&lt;[Error]&gt;&#125; 失败 */</span></span><br><span class="line">      failed: <span class="keyword">new</span> SyncHook([<span class="string">"error"</span>]),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面列出的钩子并不是所有的,做了很大的精简, 书写顺序合调用顺序一致,<a href="https://webpack.docschina.org/api/compiler-hooks/" target="_blank" rel="noopener">compiler钩子完整列表</a></p>
<h2 id="如何使用钩子"><a href="#如何使用钩子" class="headerlink" title="如何使用钩子"></a>如何使用钩子</h2><p>那么在实例化<code>Compiler</code>后生成了对象<code>compiler</code>,当我们拿到compiler对象后, 我们就可以为compiler对象上面的各种钩子添加对应的回调函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compiler = <span class="keyword">new</span> Compiler();</span><br><span class="line">compiler.hooks.compilation.tap(<span class="string">'pluginName'</span>, (compilation, params) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 通过对给对应的钩子添加回调函数, 在回调函数执行时,就可以拿到对应的对象</span></span><br><span class="line">  <span class="comment">// 泽辉这个钩子里, 我们可以拿到compilation对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>看上去载一个钩子上添加回调函数是是非容易的. 但是问题来了, 我们怎样才能获取到compiler对象呢? 这里webpack插件就需要登场了</p>
<h2 id="如何写一个插件"><a href="#如何写一个插件" class="headerlink" title="如何写一个插件"></a>如何写一个插件</h2><p>官方的plugin示例是这样的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 获得compiler了!</span></span><br><span class="line">    compiler.hooks.compilation.tap(<span class="function">(<span class="params">compilation, params</span>) =&gt;</span> &#123; </span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在定义好plugin后, 在webpack的config文件中引入这个plugin, 并在对应位置调用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plugin = <span class="built_in">require</span>(<span class="string">'./Plugin.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [<span class="keyword">new</span> Plugin()],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么我们自定义的plugin是如何调用,在什么时候注入到<code>compiler</code>里的呢?我们来看一下初始化<code>compiler</code>的代码, 我们发现在生成<code>compiler</code>的时候:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createCompiler = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  options = <span class="keyword">new</span> WebpackOptionsDefaulter().process(options);</span><br><span class="line">  <span class="comment">// 生成一个compiler对象</span></span><br><span class="line">  <span class="keyword">const</span> compiler = <span class="keyword">new</span> Compiler(options.context);</span><br><span class="line">  <span class="comment">// 依次调用插件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(options.plugins)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">"function"</span>) &#123;</span><br><span class="line">        plugin.call(compiler, compiler);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        plugin.apply(compiler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从上面的源码我们可以看出来, 插件仅仅可以是一个类, 也可以是一个函数, 使用方法大概是:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用function的方式挂载插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得compiler了!</span></span><br><span class="line">  compiler.hooks.compilation.tap(<span class="function">(<span class="params">compilation, params</span>) =&gt;</span> &#123; </span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [plugin],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一种挂载插件的方式是在使用<code>node</code> api来调用<code>webpack()</code>打包的时候, 在拿到返回的<code>compiler</code>对象后,手动调用插件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plugin = <span class="built_in">require</span>(<span class="string">'./Plugin.js'</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 手动调用插件</span></span><br><span class="line">(<span class="keyword">new</span> Plugin()).apply(compiler);</span><br></pre></td></tr></table></figure></p>
<p>不过这种方法并不适用与所有的场景, 因为在调用webpack的过程中,会有一些钩子已经运行完毕, 并不推荐.</p>
<p>上面的几个插件声明的示例都使用的是<code>compilation</code>钩子, 回调函数种可以拿到一个<code>compilation</code>对象, 那么它到底是什么呢?</p>
<h2 id="complication"><a href="#complication" class="headerlink" title="complication"></a>complication</h2><p>每一个compiler对象会在构建的时候会生成一个compilation对象, 用来保存在整个构建过程中产生的不同数据, 比如解析模块的结果缓存, 依赖模块图, 依赖文件图, chunk图等.compilation对象会在<code>compile</code>之后的大部分钩子回调中获得.</p>
<p>webpack的整个构建过程产生的数据信息都保存在compiler对象合compilation对象上,那么既然插件能够拿到这两个对象说明插件能够对webpack的全部构建流程进行干预.事实上也是如此. webpack的整个核心功能几乎都是由内部上百个私有插件呢组织而成的.所以说webpack插件的扩展能力是非常强大的.</p>
<p>compiler和compilation之间的关系:<br><img src="https://moka-sugar.oss-cn-beijing.aliyuncs.com/img/20200131182933.jpg" alt></p>
<p><code>compilation</code>对象里有大量的钩子, <a href="https://webpack.js.org/api/compilation-hooks/" target="_blank" rel="noopener">具体列表</a></p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>现在我们希望在webpack构建完毕后,获取构建时依赖的所有项目文件.</p>
<p>目前的思路是获取到compilation对象, 上面应该有所有的依赖文件列表.</p>
<p>为了保证compilation对象上的依赖文件列表是已经收集完整的了,所以我们再选择钩子的时候要确保构建过程已经结束,依赖收集已经完毕的钩子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = <span class="class"><span class="keyword">class</span> <span class="title">exportDepPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// emit钩子 说明整个构建已经完成, 准备输出文件,这是依赖已经收集完毕</span></span><br><span class="line">    compiler.hooks.emit.tagAsync(<span class="string">'exportDepPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> _fileDependencies= <span class="built_in">Array</span>.from(compilation.fileDependencies);<span class="comment">// fileDependencies是一个Set</span></span><br><span class="line">    &#125;) </span><br><span class="line">      <span class="comment">// 排除node_modules里的文件</span></span><br><span class="line">      <span class="keyword">const</span> dep = _fileDependencies.filter(<span class="function">(<span class="params">d</span>) =&gt;</span> !d.includes(<span class="string">'node_modules'</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(dep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>webpack的插件功能非常强大, 因为它能够访问到webpack构建过程中的两个核心对象,并做出干预.而且你也可以自己为这几个对象添加新的钩子,好让其他第三方插件来对你的插件进行二次扩展.</p>
<p>webpack的这种插件机制因为使用了类似发布订阅的模式,在我看来实实在在是一个双刃剑, 在提供了强大的扩展性的同时,也把相互之间的代码逻辑隐藏在了深处. 在查看源码的时候阻碍重重, 无法让编辑器进行任何静态分析.</p>
<p>想要了解更多进阶的插件使用方法, 这边建议还是看一些webpack源码, 里面有很多骚气的写法</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读:"></a>扩展阅读:</h2><p><a href="https://webpack.js.org/api/" target="_blank" rel="noopener">webpack API文档</a></p>
<p><a href="https://github.com/webpack/webpack" target="_blank" rel="noopener">webpack 项目</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/31/深入webpack-插件/" data-id="ckd5eq8f0000ctpro25vwdfuu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入webpack-tapable篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/20/深入webpack-tapable篇/" class="article-date">
  <time datetime="2019-12-20T04:23:10.000Z" itemprop="datePublished">2019-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/20/深入webpack-tapable篇/">深入webpack-tapable篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>打算写一些webpack相关的文章, 今天就先打个样</p>
<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>说到webpack, 都知道是一个打包工具, 从一个入口开始, 遍历所有依赖, 并把所有文件都打包成一个js文件, webpack在整个构建过程中需要做一系列的工作, 那么它对这些复杂的工作是怎么组织的呢?<br>当我们去看webpack源码的时候, 会发现webpack在初始化的时候调用了大量的没用过的plugin来给compiler提供各种能力, 让人眼花缭乱的plugin,就这么一个个的挂载到compiler里面, 完全看不懂到底干了点啥子, 所以让我们先看看plugin到底是个啥</p>
<h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>先让我们看一个webpack plugin 简单到不能再简单的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginName = <span class="string">'ConsoleLogOnBuildWebpackPlugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'webpack 构建过程开始！'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ConsoleLogOnBuildWebpackPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单, 所有插件都是一个class, 插件传入配置的时候会被实例化, 而webpack在注册plugin的时候会调用这个实例的apply方法, 并把这次构建的compiler作为参数传入,<br>这个compiler会在整个构建周期中存在, 那么这句到底是什么含义?<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'webpack 构建过程开始！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其实从代码上可以看到, 这段代码在compiler的钩子<code>run</code>上挂了一个插件,当这个钩子被调用的时候, 我们传入的回调函数将会被执行<code>console.log(&#39;webpack 构建过程开始！&#39;)</code>;<br>那么我们看到的个<code>hooks</code>到底是什么东西? 让我们看一下compiler的源码(注掉不需关注的代码):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">	SyncHook,</span><br><span class="line">	SyncBailHook,</span><br><span class="line">	AsyncParallelHook,</span><br><span class="line">	AsyncSeriesHook</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @param &#123;string&#125; context the compilation path</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">constructor</span>(context) &#123;</span><br><span class="line">		<span class="keyword">this</span>.hooks = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">			shouldEmit: <span class="keyword">new</span> SyncBailHook([<span class="string">"compilation"</span>]),</span><br><span class="line">			done: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"stats"</span>]),</span><br><span class="line">			afterDone: <span class="keyword">new</span> SyncHook([<span class="string">"stats"</span>]),</span><br><span class="line">			additionalPass: <span class="keyword">new</span> AsyncSeriesHook([]),</span><br><span class="line">			beforeRun: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]),</span><br><span class="line">			run: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]), <span class="comment">// &lt;------------- 上面调用的run在这里!!</span></span><br><span class="line">			emit: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compilation"</span>]),</span><br><span class="line">			assetEmitted: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"file"</span>, <span class="string">"info"</span>]),</span><br><span class="line">			afterEmit: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compilation"</span>]),</span><br><span class="line">			thisCompilation: <span class="keyword">new</span> SyncHook([<span class="string">"compilation"</span>, <span class="string">"params"</span>]),</span><br><span class="line">			compilation: <span class="keyword">new</span> SyncHook([<span class="string">"compilation"</span>, <span class="string">"params"</span>]),</span><br><span class="line">      normalModuleFactory: <span class="keyword">new</span> SyncHook([<span class="string">"normalModuleFactory"</span>]),</span><br><span class="line">      ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现Compiler类的所有hooks都是一个个不同类型的钩子的实例, 而这些钩子都来自于同一个库<code>tapable</code>.</p>
<h3 id="tapable是什么"><a href="#tapable是什么" class="headerlink" title="tapable是什么"></a>tapable是什么</h3><p><code>tapable</code>是什么?<br>早先的webpack complier 是<code>tapable</code>的实例, 现在仅仅是<code>tapable</code>的调用者, 我也觉得这样更好, 把很多调用放到外部, 远比继承一个第三方库要好, 代码的调用更明显,不再那么隐晦</p>
<p>实际上webpack编译打包类似于一个流水线, 在流水线上有很多节点, 不同的节点暴露不同的属性和值, 你可以再不同的节点对这些属性和值左调整处理, 最后直到打包完成. 那么webpack流水线中的不同的节点我们成为不同的钩子(hook), 而这些钩子就是由<code>tapable</code>负责生成的. </p>
<p>今天先说说webpack的事件机制 <code>tapable</code></p>
<p>tapable很像我们了解的发布订阅模式,我们先看看<code>tapable</code>是怎么做的</p>
<h3 id="tapable-怎么用"><a href="#tapable-怎么用" class="headerlink" title="tapable 怎么用"></a>tapable 怎么用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncHook([<span class="string">"arg1"</span>, <span class="string">"arg2"</span>, <span class="string">"arg3"</span>]);</span><br></pre></td></tr></table></figure>
<p>这里是新声明了一个钩子, 大家留意, <code>SyncHook</code>的实参传入一个数组为参数, 每一个数组item代表将来挂载这个钩子上的回调函数时能够接受到的参数数量. 即时之后我们再触发钩子时传入在多的实参, 也无法超过三个. 但是这里有一个疑问, 但是为什么要这么写? 为什么不能吧触发钩子传入的所有实参都同步给钩子的回调? 这样不是应该更加灵活么?这仅仅是一种类似注释的约定么?方便开发更快的时候钩子回调内的参数是什么? 我们这里留一手, 最后再讲</p>
<p>我们还是先来看看<code>tapable</code>里面有什么把!它会导出多种钩子类型, 从大的类型里能分为<code>SyncHook</code>, <code>AsyncSeriesHook</code>, <code>AsyncParalleHook</code>这两种, 顾名思义, 一种钩子的所有回调都是同步的, 另两种则是异步的. 两个异步钩子一种是顺序执行,也就是一个接一个, 另一个则是同步执行, 就是一次吧所有钩子回调都执行 </p>
<p>多个钩子在调用上也有不同的讲究, 通常是根据上一个钩子回调的返回值有不同的处理, 规则有如下三款, 还有一款正在设计当中</p>
<ul>
<li>basic (基本款)</li>
<li>waterfall (大瀑布款)</li>
<li>bail (保险款)</li>
<li>loop (自留款, todo…)</li>
</ul>
<p>基本款就不多说了, 所有的回调依次调用, 大家好对一个个报数就可以了<br>大瀑布款, 其实所有回调依次调用, 不同的的房是, 每一个回调都能够接受到上一个回调的返回值, 就类似于咱们的击鼓传花啦<br>保险款, 顾名思义, 跟保险丝差不多, 再依次执行回调的时候, 如果有任何一个回调有返回值, 则这个钩子的执行将提前结束</p>
<p>同步钩子和异步钩子再加上我们刚才说的三款不懂得调用处理方式, 就把整个钩子的类型翻了一倍, 下面这些也就是<code>tapable</code>提供的所有种类钩子:</p>
<ul>
<li>SyncHook</li>
<li>SyncBailHook</li>
<li>SyncWaterfallHook</li>
<li>SyncLoopHook</li>
<li>AsyncParallelHook</li>
<li>AsyncParallelBailHook</li>
<li>AsyncSeriesHook</li>
<li>AsyncSeriesBailHook</li>
<li>AsyncSeriesWaterfallHook</li>
</ul>
<p>上面知道了钩子都叫什么, 也知道了为啥叫这个名字, 下面我们就来看看钩子应该怎么用, 该怎么触发<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个钩子</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> SyncHook([<span class="string">"arg1"</span>, <span class="string">"arg2"</span>, <span class="string">"arg3"</span>]);</span><br><span class="line"></span><br><span class="line">hook.tap(<span class="string">'whatEver'</span>, (arg1, arg2, arg3) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2, arg3) <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hook.call(<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>实际上第一个参数 可以是一个对象, 里面可以有个<code>before</code>, <code>stage</code>, 用来设置这个plugin插入的位置<br>是不是相继了一般的发布订阅模式? <code>hook.tap</code>是订阅, <code>hook.call</code>是发布</p>
<p>刚我们看的是最最最简单的<code>SyncHook</code>, 他只有一种挂在钩子回调的方法, 就是<code>tap</code>, 实际上不同的钩子类型, 它提供的挂载方式也不同, 分成三种</p>
<ul>
<li>tap</li>
<li>tapPromise</li>
<li>tapAsync<br>区别也挺简单的, <code>tap</code>就是同步挂载,挂载的回调函数自然是一个同步函数, <code>tapPromise</code>挂载的异步函数了, 要求他必须返回一个<code>Promise</code>, <code>tabAsync</code>挂载的也是一个异步函数, 函数中的形参<code>callback</code>代表着函数的结束, 类似<code>express</code>的<code>next</code>.</li>
</ul>
<p><code>tapable</code>也有拦截器, 其实就是在每个钩子的不同状态触发前的一个控制函数, 让你对整个钩子有更多的控制能力<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hook.intercept(&#123;</span><br><span class="line">  context: <span class="literal">true</span>, <span class="comment">// 开启时, 可以再拦截函数的第一个参数拿到context对象, context对象也可以从所有的钩子回调中获得</span></span><br><span class="line">  <span class="comment">// hook 触发时</span></span><br><span class="line">	call: <span class="function">(<span class="params">arg1, arg2, arg2</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// hook 注册时</span></span><br><span class="line">	register: <span class="function">(<span class="params">tapInfo</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> tapInfo; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有新的钩子回调挂进来时</span></span><br><span class="line">  tap: <span class="function">(<span class="params">tap</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/20/深入webpack-tapable篇/" data-id="ckd5eq8ez000btprosvul9211" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端N面-elm-lang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/22/前端N面-elm-lang/" class="article-date">
  <time datetime="2019-11-22T06:25:07.000Z" itemprop="datePublished">2019-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/22/前端N面-elm-lang/">前端N面-elm-lang</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="elm是什么"><a href="#elm是什么" class="headerlink" title="elm是什么?"></a>elm是什么?</h2><p><del>他是一个著名的外卖平台</del></p>
<p>elm是一门开发语言, 是一门函数式语言, 但是不同于其他函数式语言, 因为这门语言只聚焦在前端开发方面, 也就是说,最后它能够编译成javascript.<br>elm是一门很年轻的语言, Evan Czaplicki 再2012年才把它设计出来, 而且是在他的毕业设计上(大雾)…<br>但是尽管elm非常年轻, 但显然它再前端圈里也是有这举足轻重的地位的,至于为什么, 我们稍后再说</p>
<h2 id="为什么我们需要了解elm"><a href="#为什么我们需要了解elm" class="headerlink" title="为什么我们需要了解elm"></a>为什么我们需要了解elm</h2><p>最近两年, 因为react 和redux 的函数式编程思想, 导致前端的函数式编程大热. 我们不谈函数式编程真正能给前端带来什么,仅仅说函数式编程作为一种完全不同编程范式,<br>再学习这种编程思想的同时, 一定能过扩宽我们的编程思路, 一些偏函数式的库的出发点和基石, 毕竟再js里函数也是一等公民<br>如今前端框架吸收函数式编程以及强类型语言优点的形势下, 甚至可能会开启我们对前端的重新认识</p>
<h2 id="elm有什么特点"><a href="#elm有什么特点" class="headerlink" title="elm有什么特点?"></a>elm有什么特点?</h2><ul>
<li>强类型 (static type)</li>
<li>函数式语言 (fpr)</li>
<li>一次编译, (处处运行?) No Runtime Exceptions</li>
<li>数据不可变 (immutable) </li>
<li>虚拟dom (Great Performance)</li>
</ul>
<h2 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h2><p>elm的语法是来源于haskell的,虽然不是haskell的方言, 但还是吸收了很多形式,一下不会完全展开,<br>直挑一些后面实例用的到的一些语法做介绍</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><code>list</code>和js里的<code>array</code>类似, 但是每一个值都必须是相同的类型<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="comment">-- correct </span></span><br><span class="line"><span class="title">a</span> = [<span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="comment">-- wrong</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h3><p>Record 和js里的<code>Object</code>很像, 他的定义方法是:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">john</span> = &#123; first = <span class="string">"John"</span>, last = <span class="string">"Hobson"</span>, age = <span class="number">25</span> &#125;</span><br><span class="line"></span><br><span class="line">.last john // <span class="string">"Hobson"</span>  .last 是一个records访问器</span><br><span class="line"></span><br><span class="line"><span class="title">john</span>.last // <span class="string">"Hobson"</span> 直接访问last</span><br><span class="line"></span><br><span class="line">&#123;john | last = 'blabla' &#125; // &#123; first = "John", last = "blabla", age = 25 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">add</span> : <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> // 类型定义</span><br><span class="line"><span class="title">add</span> a b = a + b // function add (a,b) &#123;return a + b&#125;</span><br><span class="line"><span class="title">add</span> <span class="number">1</span> <span class="number">2</span>  // <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这里就可以发现elm的函数式特点, 再我们定义一个函数的时候, 如果有多个参数, 参数和参数之间的定义使用<code>-&gt;</code>来分割的,<br>其实这也表名了这个函数是被科里化的,函数的执行可以被分解成以下两部</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">temp</span> = add <span class="number">1</span> // init -&gt; init</span><br><span class="line"><span class="title">temp</span> <span class="number">2</span> // <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>再elm里所有的函数都是被科里化的, 科里化的好处? 打个比方<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repeat(<span class="number">10</span>, <span class="string">'a'</span>) <span class="comment">// 'aaaaaaaaaa'</span></span><br><span class="line"><span class="comment">// 科里化后</span></span><br><span class="line">repeat(<span class="number">10</span>)(<span class="string">'a'</span>) <span class="comment">// 'aaaaaaaaaa'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有科里化</span></span><br><span class="line">repeat10(str) &#123;</span><br><span class="line">  <span class="keyword">return</span> repeat(<span class="number">10</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 科里化的</span></span><br><span class="line">repeat10 = repeat(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>因为是函数式语言, 会出现多层的函数嵌套,比如再js中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = fa(param);</span><br><span class="line">  <span class="keyword">let</span> b = fb(a);</span><br><span class="line">  <span class="keyword">let</span> c = fc(c);</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fc(fb(fa(param)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你也可以通过<code>lodash</code> 或者 <code>ramda</code> 这样的fp工具库来做链式调用, 这里就不一一展开, 感兴趣的可以看对应的文档</p>
<p>而再elm里, 就有专门的语法来处理这种情况<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">param</span> = </span><br><span class="line">  param</span><br><span class="line">    |&gt;fa</span><br><span class="line">    |&gt;fb</span><br><span class="line">    |&gt;fc</span><br></pre></td></tr></table></figure></p>
<p>一个字, 优雅</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>elm是一个强类型语言, 所以显然我们需要对类型做定义, 这里重点讲一下elm里面的union type, 因为这是elm的重要核心</p>
<p>####普通类型<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> : <span class="type">String</span> </span><br><span class="line">User tom = 'tom'</span><br><span class="line"><span class="type">User</span> num = <span class="number">1</span> // error</span><br></pre></td></tr></table></figure></p>
<p>####Union Type<br>Union type 用来表示一组可能tag集合,比如Hr, Admin 都是User的一个variants</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">User</span> = <span class="type">Hr</span> <span class="type">String</span> | <span class="type">Admin</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>而Union type 也可以被解构<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getUserLabel</span>: <span class="type">User</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">getUserLabel</span> user = </span><br><span class="line">  <span class="keyword">case</span> user <span class="keyword">of</span></span><br><span class="line">    <span class="type">Hr</span> name -&gt;</span><br><span class="line">      name</span><br><span class="line">    <span class="type">Admin</span> name -&gt;</span><br><span class="line">      role ++ name</span><br><span class="line"></span><br><span class="line">```elm</span><br><span class="line">注意`<span class="keyword">case</span> user <span class="keyword">of</span>`下面的代码, 是不是和js里的`switch`很像? 所以union <span class="keyword">type</span>很多情况都被当做是一种条件判断</span><br><span class="line"></span><br><span class="line">```elm</span><br><span class="line"><span class="keyword">type</span> <span class="type">User</span> = <span class="type">Guest</span> <span class="type">String</span> | <span class="type">Admin</span> <span class="type">String</span> <span class="type">Int</span> </span><br><span class="line"><span class="title">getWelcomeMessage</span>: <span class="type">User</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">getWelcomeMessage</span> user =</span><br><span class="line">  <span class="keyword">case</span> user <span class="keyword">of</span></span><br><span class="line">     <span class="type">Guest</span> _-&gt;</span><br><span class="line">      <span class="string">"guest login!"</span></span><br><span class="line">    <span class="type">Admin</span> _ _ -&gt;</span><br><span class="line">      <span class="string">"admin login! welcome back!"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>ok, 学完上面的几个知识点, 我们开始看一个简单的示例,来了解一个elm程序是如何构成的吧!</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Main <span class="keyword">exposing</span> (..)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Browser</span><br><span class="line"><span class="keyword">import</span> Html <span class="keyword">exposing</span> (<span class="type">Html</span>, button, div, text, span, input)</span><br><span class="line"><span class="keyword">import</span> Html.Events <span class="keyword">exposing</span> (onClick, onInput)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MAIN</span></span><br><span class="line"><span class="title">main</span> =</span><br><span class="line">  <span class="type">Browser</span>.sandbox &#123; init = init, update = update, view = view &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MODEL</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">alias</span> <span class="type">Model</span> =  &#123; count: <span class="type">Int</span> &#125; </span><br><span class="line"></span><br><span class="line"><span class="title">init</span> : <span class="type">Model</span></span><br><span class="line"><span class="title">init</span> = &#123; count = <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- UPDATE</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">Msg</span> = <span class="type">Increment</span> | <span class="type">Decrement</span> </span><br><span class="line"></span><br><span class="line"><span class="title">update</span> : <span class="type">Msg</span> -&gt; <span class="type">Model</span> -&gt; <span class="type">Model</span></span><br><span class="line"><span class="title">update</span> msg model =</span><br><span class="line">  <span class="keyword">case</span> msg <span class="keyword">of</span></span><br><span class="line">    <span class="type">Increment</span> -&gt;</span><br><span class="line">      &#123; model | count = model.count + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Decrement</span> -&gt;</span><br><span class="line">      &#123; model | count = model.count + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- VIEW</span></span><br><span class="line"><span class="title">view</span> : <span class="type">Model</span> -&gt; <span class="type">Html</span> <span class="type">Msg</span></span><br><span class="line"><span class="title">view</span> model =</span><br><span class="line">  div []</span><br><span class="line">    [ button [ onClick <span class="type">Decrement</span> ] [ text <span class="string">"-"</span> ]</span><br><span class="line">    , div [] [ text (<span class="type">String</span>.fromInt model.count) ]</span><br><span class="line">    , button [ onClick <span class="type">Increment</span> ] [ text <span class="string">"+"</span> ]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>这里<code>view</code>是一个函数,它使用当前的<code>model</code>l来渲染dom, 使用的是类似<code>jsx</code>的函数调用, 这是一个纯的标准的函数式组件</p>
<p><code>update</code>函数接受 <code>Msg</code>, 根据不同variants来对model做更新, 这和redux的reducer是非常类似的, 不同的variants就类似于不同的<code>actionType</code><br>状态被一个纯函数来更新,并返回一个新的状态</p>
<p><code>init</code>定义了当前的初识状态</p>
<p>最后形成一个数据流 init -&gt; view -&gt; update -&gt; init 这样的一个单向数据流</p>
<p>上面就是一个简单的例子, 能够很好的提现elm开发的理念, 和它的代码解构, 先看一下上面的几行注释,<br>能明显看出来, 代码把程序分成几个部分:</p>
<ul>
<li>数据 (model  the state of your application)</li>
<li>视图 (view  a way to turn your state into HTML)</li>
<li>更新 (update  a way to update your state based on messages)</li>
</ul>
<p>elm管这种结构叫做 <code>elm architecture</code>,<br><img src="https://guide.elm-lang.org/architecture/buttons.svg" alt="elm architecture"></p>
<p>是不是很像redux的逻辑?实际上并不是elm借鉴了redux, 而是redux借鉴了elm! 同时也顺便激发了<code>dva</code></p>
<blockquote>
<p>I read about Elm before Redux but didn’t get it fully, later realized it was important influence. – Dan Abrawov</p>
</blockquote>
<blockquote>
<p>Lightweight front-end framework based on redux, redux-saga and react-router. (Inspired by elm and choo) – Dva</p>
</blockquote>
<h3 id="Side-Effects"><a href="#Side-Effects" class="headerlink" title="Side Effects"></a>Side Effects</h3><p>刚才一直在说<code>elm</code>都是纯函数, 但是在实际开发中, 是不可能这么完美的, 我们有很多场景都是不纯粹的, 比如io, network, 和其他js代码交互 等等, <code>elm</code>使用<code>port</code>, 和他本身的rentime封装了这层逻辑,<br>这样隔离了这些有副作用的逻辑<br><img src="https://elmprogramming.com/images/chapter-5/5.5-side-effects/elm-runtime.svg" alt="img"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>实际上, 目前很少有人在再生产环境使用elm, 一方面是因为它的社区不够强大, 还有一方面是文档不够完善, 再有就是比较陡峭的学习成本, 往往让人望而生畏  </p>
<p>不过如果真的要入手学习的话, 作者写的<a href="https://github.com/evancz/elm-todomvc" target="_blank" rel="noopener">TODOMVC</a>,看明白就很不错啦<br>如果你敢再生产环境使用, 那你是真正的勇士(其实还真有)</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>  <a href="https://elm-lang.org/" target="_blank" rel="noopener">elm官网</a>  </p>
<p>  <a href="https://github.com/paldepind/functional-frontend-architecture" target="_blank" rel="noopener">functional-frontend-architecture, 如何用纯js撸一个elm architecture</a>  </p>
<p>  <a href="https://elmprogramming.com/" target="_blank" rel="noopener">更详细的教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/22/前端N面-elm-lang/" data-id="ckd5eq8ew0008tprov2v74aoa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-初识Svelte" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/25/初识Svelte/" class="article-date">
  <time datetime="2019-10-25T06:32:25.000Z" itemprop="datePublished">2019-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/25/初识Svelte/">初识Svelte</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是Svelte"><a href="#什么是Svelte" class="headerlink" title="什么是Svelte?"></a>什么是Svelte?</h2><p>首先, svelte是一个前端框架, 在国内使用人数非常少, 但是如果你到github上去看它的repo,你会发现居然有25.3k的star.<br>什么? 居然这么多? 为啥我没听过呢? 不是只有三大框架么? (问号脸?)<br>那今天就来给大家介绍一下它和我们熟悉的另外几个常见框架<code>react</code> <code>vue</code> 有什么区别?</p>
<h2 id="Svelte有什么特点"><a href="#Svelte有什么特点" class="headerlink" title="Svelte有什么特点"></a>Svelte有什么特点</h2><p>让我们先看一下用<code>svelte</code>来书写组件是什么样子的:</p>
<p>try.svelte<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> count = <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">		count += 1;</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">on:click</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="line">	Clicked &#123;count&#125; &#123;count === 1 ? 'time' : 'times'&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们有一说一, 是不是有点像<code>vue</code>的写法? 看想去很像是<code>.vue</code>的文件嘛!? 但又好少点什么?</p>
<p>没有错! 就是少了很多东西, 首先旧少了框架的引入, 也少了很多声明试的代码,如果让你用<code>vue</code> <code>react</code> 来写这个代码逻辑的话,<br>恐怕都没法写的这么精简把? 其实这就是<code>Svelte</code>框架对外宣称的第一个特点: ‘Write less code’, 整个代码几乎没有任何样板代码,<br>看上去十分清爽, 也刚容易理解</p>
<p>实际上通常一个功能的代码量, <code>svelte</code>要比 <code>react</code>少不少:<br><img src="https://static001.infoq.cn/resource/image/e0/7f/e0bfee0f9437fc88a1a6928738af117f.jpg" alt="对比"></p>
<p>让我们看看代码为什么这么少?我们发现代码在对变量更新的时候并没有使用类似<code>react</code>的<code>setState</code>方法, 而是直接对变量进行了再赋值.<br>仅仅是对变量进行了赋值就可以引发视图的变化, 很显然是数据响应的, 这就是<code>svelte</code>的第二个特点: ‘truly reactive’</p>
<p>但是它又很奇怪,因为它像vue一样吧变量声明到一个对象中来进行数据劫持, 那到底是怎么做到的呢?</p>
<p>让我们看看他编译以后的代码, 编译以后变成了这样…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* App.svelte generated by Svelte v3.12.1 */</span></span><br><span class="line"><span class="keyword">import</span> &#123; SvelteComponent, append, detach, element, init,</span><br><span class="line">	insert, listen, noop, safe_not_equal, set_data, space, text</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"svelte/internal"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_fragment</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> button, t0, t1, t2, t3_value = ctx.count === <span class="number">1</span> ? <span class="string">'time'</span> : <span class="string">'times'</span> + <span class="string">""</span>, t3, dispose;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		c() &#123;</span><br><span class="line">			button = element(<span class="string">"button"</span>); <span class="comment">// 创建一个button</span></span><br><span class="line">			t0 = text(<span class="string">"Clicked "</span>);  </span><br><span class="line">			t1 = text(ctx.count); <span class="comment">// 变量count 的textnode</span></span><br><span class="line">			t2 = space(); <span class="comment">// 空格?</span></span><br><span class="line">			t3 = text(t3_value); <span class="comment">// 之前的三元表达式的结果 的 textnode</span></span><br><span class="line">			dispose = listen(button, <span class="string">"click"</span>, ctx.handleClick); <span class="comment">// 给button元素添加点击时间</span></span><br><span class="line">		&#125;,</span><br><span class="line">		m(target, anchor) &#123;</span><br><span class="line">			insert(target, button, anchor); <span class="comment">// 插入到目标元素</span></span><br><span class="line">			append(button, t0); <span class="comment">//  把文本添加到button上</span></span><br><span class="line">			append(button, t1);</span><br><span class="line">			append(button, t2);</span><br><span class="line">			append(button, t3);</span><br><span class="line">		&#125;,</span><br><span class="line">		p(changed, ctx) &#123;  <span class="comment">// 数据到dom的操作函数, 这里直接改document上的对应元素了!</span></span><br><span class="line">			<span class="keyword">if</span> (changed.count) &#123; set_data(t1, ctx.count); &#125; <span class="comment">// 更新 count textnode</span></span><br><span class="line">			<span class="keyword">if</span> ((changed.count) &amp;&amp; t3_value !== (t3_value = ctx.count === <span class="number">1</span> ? <span class="string">'time'</span> : <span class="string">'times'</span> + <span class="string">""</span>)) &#123;</span><br><span class="line">				set_data(t3, t3_value); <span class="comment">// 更新三元表达式的 textnode</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		i: noop, <span class="attr">o</span>: noop,</span><br><span class="line">		d(detaching) &#123; <span class="comment">// 销毁组件</span></span><br><span class="line">			<span class="keyword">if</span> (detaching) &#123; detach(button); &#125;</span><br><span class="line">			dispose();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">$$self, $$props, $$invalidate</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 真正的变量声明初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// click回调 初始化</span></span><br><span class="line">		$$invalidate(<span class="string">'count'</span>, count += <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123; count, handleClick &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">SvelteComponent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		init(<span class="keyword">this</span>, options, instance, create_fragment, safe_not_equal, []);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>what? 没法看了,对不对? 让我们回过头仔细看看代码…</p>
<p>看完注释, 是不是大概搞明白了. 这不就是jQuery么!</p>
<p>没错, 大概意思差不多, 其实把<code>svelte</code>称作一个前端框架是不恰当的, 他更应该被称作编译器, 把开头的<code>.svelet</code>文件编译成上面的可执行代码.<br>而且编译后的代码中调用的大多数方法都是一些helper function, 所以<code>svelte</code>的runtime代码量是非常少的,它主要的工作都是在编译期完成的.</p>
<p>并且我们发现,数据和视图的绑定,使用的是vanillaJs, 数据的变动,直接修改对应的dom节点,也就是说,他并没有用<code>virtual dom</code>!<br>这就是<code>svelte</code>的第三个卖点: ‘no virtual dom’. 显然我们不需要猜测也知道, 他的性能会很好.</p>
<p>作者在官网上说:</p>
<blockquote>
<p>虚拟DOM不是一种功能。而是一种声明性的，状态驱动的UI开发,的最终手段.因为它使你无需考虑状态转换即可构建应用程序，并且性能通常足够好。这意味着更少的错误代码，而将更多的时间花费构建功能上，而不是乏味的工作上. 但是事实证明，我们无需使用虚拟DOM就可以实现类似的编程模型-这就是Svelte的用武之地。</p>
</blockquote>
<p>实际上最后, <code>svelte</code>编译好的代码是不再需要任何依赖的,是一个天然的组件, 只要把导出的类直接实例化, 组件就被正确的添加了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="keyword">new</span> App(&#123;</span><br><span class="line">  target: <span class="built_in">document</span>.body,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>所以<code>svelte</code>很容易被嵌入到其他框架中去使用</p>
<h2 id="svelte潜在的问题"><a href="#svelte潜在的问题" class="headerlink" title="svelte潜在的问题"></a>svelte潜在的问题</h2><ul>
<li>虽然它只有很少的运行时代码,但他构建后的代码,有可能比用<code>virtual dom</code>构建的代码多,并且有很多运行时代码的重复调用. 随着项目的扩大,运行时代码的体量优势也会越来越小, 最终实际生产项目中能有多少尺寸的优势很难说</li>
<li>虽然编译后的代码性能几乎和 vanillaJs持平, 现在主流框架的virtual dom 也可以做到只比vanillaJs慢1.5倍左右, 这也证明了为了web页面的性能的瓶颈很可能不在dom本身,而在框架</li>
<li>svelte的这种实现逻辑导致它无法被像<code>virtual dom</code>这样, 容易静态分析,继而移植为服务端渲染, 也很难基于vNode进行测试</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不论如何,不得不说, 作者在整个框架思路上,非常的清奇,与众不同. 看完让我眼前一亮. 果然<code>virtual dom</code> 并不一定是前端的的最佳实践 前端还会有很多路要走, 我们也有很多代码值得去看.<br>最后提一句, 作者操作这么秀, 一定不是普通人,对吧? 他就是前端轮子哥, 也是<code>rollup</code>的作者 Rich-Harris. <a href="https://github.com/Rich-Harris" target="_blank" rel="noopener">这是他的github</a></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://svelte.dev" target="_blank" rel="noopener">svelte 官网</a><br><a href="https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969/" target="_blank" rel="noopener">Truly reactive programming with Svelte 3.0</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/25/初识Svelte/" data-id="ckd5eq8et0005tprokseb314s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-10分钟上手ast" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/29/10分钟上手ast/" class="article-date">
  <time datetime="2019-08-29T12:06:26.000Z" itemprop="datePublished">2019-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/29/10分钟上手ast/">10分钟上手ast</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是AST"><a href="#什么是AST" class="headerlink" title="什么是AST"></a>什么是AST</h2><p> AST(Abstract Syntax Tree)简称是抽象语法树,是源代码语法结构的一种抽象表示.它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构.<br> 比如一下代码:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p> 这行代码大致会被解析为以下ast<br> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"VariableDeclaration"</span>,</span><br><span class="line">  <span class="attr">"declarations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"VariableDeclarator"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"a"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"init"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"NumericLiteral"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"kind"</span>: <span class="string">"const"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里推荐一个工具 <a href="https://astexplorer.net/" target="_blank" rel="noopener">ast explorer</a>, 它可以帮你快速把代码转换成ast, 提高你的开发效率</p>
<p> 可以看出来, 代码变成了一个树结构的数组对象, 描述了一个对一个变量的赋值. 那么我们能用ast来做点什么呢?</p>
<h2 id="重新认识babel"><a href="#重新认识babel" class="headerlink" title="重新认识babel"></a>重新认识babel</h2><p> 社区里, 能够解析js代码到ast的工具有很多, 这里我们就使用大家都比较熟悉的babel来举例</p>
<p> <code>babel</code>是一个js编译器,能够把es6等语法编译成es5, 并且他还提供了丰富的工具,可以让我们做很多我们想干的事情.比如:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'element'</span></span><br></pre></td></tr></table></figure></p>
<p> 转化成:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'element/lib/Button'</span></span><br></pre></td></tr></table></figure></p>
<p>如果想完成这样的事情,我们需要大概了解一下babel的工具包  </p>
<ol>
<li><code>@babel/parser</code>用来把js代码转换成ast</li>
<li><code>@babel/traverse</code>用来帮助你遍历ast</li>
<li><code>@babel/types</code> 用来帮助你判断ast节点,或生成相应的节点</li>
<li><code>@babel/generator</code> 用来把ast从新转换成js代码</li>
</ol>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>让我们想一下, 如果要把代码a转变成代码b, 应该是一个什么思路?我的思路是:</p>
<ol>
<li>先吧js转换成ast</li>
<li>遍历ast收集信息</li>
<li>更具收集的信息生成ast</li>
<li>把新生城的ast转换为js代码并输出</li>
</ol>
<h3 id="第一步-转换ast"><a href="#第一步-转换ast" class="headerlink" title="第一步,转换ast"></a>第一步,转换ast</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">'@babel/parser'</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"@babel/traverse"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">"import &#123; Button &#125; from 'element'"</span>;</span><br><span class="line"><span class="comment">// 生成传入code的ast</span></span><br><span class="line"><span class="keyword">const</span> ast = parse(code);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [];</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">    ImportDeclaration: <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;  <span class="comment">// 只处理import语句</span></span><br><span class="line">      <span class="keyword">const</span> sourceValue = path.node.source.value;</span><br><span class="line">      <span class="keyword">if</span> (sourceValue === <span class="string">'element'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (types.isImportSpecifier(specifier)) &#123;  <span class="comment">// 只处理解构方式声明的变量明</span></span><br><span class="line">          <span class="comment">// 拿到所有结构的变量名</span></span><br><span class="line">          names.push(specifier.local.name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据收集到的解构变量名list,生成新的ast</span></span><br><span class="line"><span class="keyword">const</span> body = names.map(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> source = types.stringLiteral(<span class="string">`element/lib/<span class="subst">$&#123;name&#125;</span>`</span>); <span class="comment">// 生成source节点</span></span><br><span class="line">  <span class="keyword">const</span> specifier = types.importDefaultSpecifier(types.identifier(name)); <span class="comment">// 生成 specifier节点</span></span><br><span class="line">  <span class="keyword">return</span> types.ImportDeclaration([specifier], source);  <span class="comment">// 生成Import声明节点</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在外面包了一层program节点, 生成完整的树</span></span><br><span class="line"><span class="keyword">const</span> convertedAst = types.program(body, [], <span class="string">'module'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把ast转换成js代码并输出</span></span><br><span class="line"><span class="keyword">const</span> convertCode = generator(convertedAst).code;</span><br><span class="line"><span class="keyword">return</span> convertCode; <span class="comment">// import Button from 'element/lib/Button'</span></span><br></pre></td></tr></table></figure>
<p>以上就是这个简单小功能的用法, 可以发现其实就是按部就班的来,类似于把大象放进冰箱的思路</p>
<p>其实在生成js代码的时候也可以用<code>@babel/template</code>来做, 也可能会更方便, 相关的工具api可以再babel的主页上查找</p>
<p>也许这个babel的小栗子可以为你打开一扇门, 让你能够知道, 其实你可以做的更多</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/29/10分钟上手ast/" data-id="ckd5eq8eo0002tpro8tw31hu4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/28/理解前端依赖/">理解前端依赖</a>
          </li>
        
          <li>
            <a href="/2020/06/30/理解DSL/">理解DSL</a>
          </li>
        
          <li>
            <a href="/2020/05/19/你真的知道react-redux是怎么运行的么/">你真的知道react-redux是怎么运行的么</a>
          </li>
        
          <li>
            <a href="/2020/04/27/如何设计一个简单的模块系统/">如何设计一个简单的模块系统</a>
          </li>
        
          <li>
            <a href="/2020/03/29/如何设计一个插件系统/">如何设计一个插件系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>